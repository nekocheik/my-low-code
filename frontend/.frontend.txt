/// my-low-code-app/frontend/src/App.tsx

// frontend/src/App.tsx

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ChakraProvider } from '@chakra-ui/react';
import { AuthProvider } from './contexts/AuthContext';
import { AlertProvider } from './contexts/AlertContext';
import { ProjectProvider } from './contexts/ProjectContext';
import { GraphProvider } from './contexts/GraphContext';
import { CombinedProvider } from './contexts/CombinedContext';
import { ModalProvider } from './contexts/ModalContext';
import { ProtectedRoute } from './components/ProtectedRoute';
import { LoginPage } from './pages/LoginPage';
import { RegisterPage } from './pages/RegisterPage';
import { MainApp } from './components/MainApp';
import { Header } from './components/Header';
import { ReactFlowProvider } from 'reactflow';
import ErrorBoundary from './components/ErrorBoundary';

const App: React.FC = () => {
  return (
    <ChakraProvider>
      <AlertProvider>
        <AuthProvider>
          <ProjectProvider> {/* ProjectProvider enveloppe GraphProvider */}
            <GraphProvider> {/* GraphProvider dépend de ProjectProvider */}
              <CombinedProvider> {/* CombinedProvider dépend de GraphProvider */}
                <ErrorBoundary>
                  <ModalProvider>
                    <ReactFlowProvider>
                      <Router>
                        <Header />
                        <Routes>
                          <Route path="/login" element={<LoginPage />} />
                          <Route path="/register" element={<RegisterPage />} />
                          <Route
                            path="/"
                            element={
                              <ProtectedRoute>
                                <MainApp />
                              </ProtectedRoute>
                            }
                          />
                          <Route path="*" element={<Navigate to="/" replace />} />
                        </Routes>
                      </Router>
                    </ReactFlowProvider>
                  </ModalProvider>
                </ErrorBoundary>
              </CombinedProvider>
            </GraphProvider>
          </ProjectProvider>
        </AuthProvider>
      </AlertProvider>
    </ChakraProvider>
  );
};

export default App;


---------
/// my-low-code-app/frontend/src/axiosInstance.ts

// frontend/src/axiosInstance.ts

import axios from 'axios';

const axiosInstance = axios.create({
  baseURL: 'http://localhost:3000', // Ajustez selon votre configuration
  headers: {
    'Content-Type': 'application/json',
  },
});

axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token && config.headers) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    // Vous pouvez ajouter une logique ici pour gérer les erreurs globales
    return Promise.reject(error);
  }
);

export default axiosInstance;

---------
/// my-low-code-app/frontend/src/components/CodeNode.tsx

// frontend/src/components/CodeNode.tsx

import React, { useState, useCallback, useEffect } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Box, Button, Input, VStack, HStack, Text } from '@chakra-ui/react';
import MonacoEditor from '@monaco-editor/react';
import Select from 'react-select';
import { useGraph } from '../contexts/GraphContext';
import axiosInstance from '../axiosInstance'; // Assurez-vous que ce chemin est correct
import { useProject } from '../contexts/ProjectContext';
import { useAlert } from '../contexts/AlertContext';
import { ResizableBox } from 'react-resizable';
import 'react-resizable/css/styles.css';

const CodeNode: React.FC<NodeProps> = ({ id, data }) => {
  const [code, setCode] = useState(data.code || '');
  const [fileName, setFileName] = useState(data.fileName || '');
  const [imports, setImports] = useState<string[]>(data.imports || []);
  const [availableImports, setAvailableImports] = useState<{ value: string; label: string }[]>([]);
  const [width, setWidth] = useState<number>(300);
  const [height, setHeight] = useState<number>(400);
  const { updateGraph, deleteNode, cloneNode, nodes, edges } = useGraph();
  const { selectedProject } = useProject();
  const { showAlert } = useAlert();

  useEffect(() => {
    axiosInstance
      .get('/accessible-functions', {
        params: { project: selectedProject, nodeId: id },
      })
      .then((response) => {
        const options = response.data.accessibleFunctions.map((func: string) => ({
          value: func,
          label: func,
        }));
        setAvailableImports(options);
      })
      .catch((error) => {
        console.error('Failed to fetch accessible functions:', error);
        showAlert('Échec de la récupération des fonctions accessibles.', 'error');
      });
  }, [id, selectedProject, showAlert]);

  const handleImportChange = (selectedOptions: any) => {
    const selectedImports = selectedOptions ? selectedOptions.map((option: any) => option.value) : [];
    setImports(selectedImports);
  };

  const handleResize = (event: any, { size }: { size: { width: number; height: number } }) => {
    setWidth(size.width);
    setHeight(size.height);
  };

  const handleSave = useCallback(async () => {
    const updatedNodes = nodes.map((node) =>
      node.id === id
        ? { ...node, data: { ...node.data, code, fileName, imports }, position: { ...node.position }, width, height }
        : node
    );

    try {
      await updateGraph(updatedNodes, edges);
      showAlert('Fichier sauvegardé avec succès.', 'success');
    } catch (error: any) {
      console.error('Failed to save file:', error);
      if (error.response && error.response.data && error.response.data.message) {
        showAlert(`Échec de la sauvegarde du fichier: ${error.response.data.message}`, 'error');
      } else {
        showAlert('Échec de la sauvegarde du fichier.', 'error');
      }
    }
  }, [id, code, fileName, imports, nodes, edges, updateGraph, showAlert, width, height]);

  const handleExecute = useCallback(() => {
    console.log(`Dispatching executeNode event for nodeId: ${id}`);
    const event = new CustomEvent('executeNode', { detail: { nodeId: id } });
    window.dispatchEvent(event);
  }, [id]);

  const handleDelete = useCallback(() => {
    deleteNode(id);
  }, [id, deleteNode]);

  const handleClone = useCallback(() => {
    cloneNode(id);
  }, [id, cloneNode]);

  return (
    <ResizableBox width={width} height={height} onResize={handleResize} minConstraints={[200, 200]} maxConstraints={[600, 600]}>
      <Box borderWidth={1} borderRadius="lg" p={3} bg="white" width="100%" height="100%">
        <VStack spacing={3}>
          <Input
            value={fileName}
            onChange={(e) => setFileName(e.target.value)}
            placeholder="Nom du fichier"
          />
          <Box>
            <Text fontWeight="bold">Imports Internes :</Text>
            <Select
              isMulti
              options={availableImports}
              value={availableImports.filter(option => imports.includes(option.value))}
              onChange={handleImportChange}
              placeholder="Sélectionner des imports"
            />
          </Box>
          <Box height={150} width="100%">
            <MonacoEditor
              height="100%"
              language="javascript"
              theme="vs-dark"
              value={code}
              onChange={(value) => setCode(value || '')}
              options={{ minimap: { enabled: false } }}
            />
          </Box>
          {data.lintErrors && data.lintErrors.length > 0 && (
            <Box>
              <Text color="red.500" fontWeight="bold">Erreurs de lint :</Text>
              {data.lintErrors.map((error: any, index: number) => (
                <Text key={index} color="red.500">{`Ligne ${error.line}: ${error.message}`}</Text>
              ))}
            </Box>
          )}
          <HStack spacing={2}>
            <Button size="sm" colorScheme="blue" onClick={handleSave}>Sauvegarder</Button>
            <Button size="sm" colorScheme="green" onClick={handleExecute}>Exécuter</Button>
            <Button size="sm" colorScheme="red" onClick={handleDelete}>Supprimer</Button>
            <Button size="sm" colorScheme="purple" onClick={handleClone}>Cloner</Button>
          </HStack>
        </VStack>
        <Handle type="target" position={Position.Top} />
        <Handle type="source" position={Position.Bottom} />
      </Box>
    </ResizableBox>
  );
};

export default CodeNode;


---------
/// my-low-code-app/frontend/src/components/Console.tsx

// frontend/src/components/Console.tsx

import React, { useState, useEffect } from 'react';
import { Box, Text, VStack, Button, Input, HStack } from '@chakra-ui/react';
import { useCombined } from '../contexts/CombinedContext'; // Utiliser useCombined
import axiosInstance from '../axiosInstance';
import { useAlert } from '../contexts/AlertContext';
import { useModal } from '../contexts/ModalContext'; // Utiliser useModalContext

export const Console: React.FC = () => {
  const [output, setOutput] = useState('');
  const [command, setCommand] = useState('');
  const { executeNode } = useCombined(); // Utiliser useCombined
  const { selectedProject } = useCombined(); // Utiliser useCombined
  const { showAlert } = useAlert();

  useEffect(() => {
    const handleNodeExecution = async (event: Event) => {
      const customEvent = event as CustomEvent;
      try {
        const result = await executeNode(customEvent.detail.nodeId);
        const newOutput = `${result.stdout}\n${result.stderr}`;
        console.log('New Output:', newOutput);
        setOutput(prevOutput => `${prevOutput}\n${newOutput}`);
      } catch (error) {
        const errorOutput = `Erreur lors de l'exécution du nœud: ${error}`;
        console.log(errorOutput);
        setOutput(prevOutput => `${prevOutput}\n${errorOutput}`);
        showAlert('Erreur lors de l\'exécution du nœud.', 'error');
      }
    };

    window.addEventListener('executeNode', handleNodeExecution);

    return () => {
      window.removeEventListener('executeNode', handleNodeExecution);
    };
  }, [executeNode, showAlert]);

  const executeCommand = async () => {
    if (!command.trim()) return;

    try {
      const response = await axiosInstance.post('/execute-command', {
        project: selectedProject,
        command,
      });
      const newOutput = `${response.data.stdout}\n${response.data.stderr}`;
      setOutput(prevOutput => `${prevOutput}\n${newOutput}`);
      setCommand('');
      showAlert('Commande exécutée avec succès.', 'success');
    } catch (error: any) {
      const errorOutput = `Erreur lors de l'exécution de la commande: ${error.response?.data?.message || error.message}`;
      setOutput(prevOutput => `${prevOutput}\n${errorOutput}`);
      showAlert('Erreur lors de l\'exécution de la commande.', 'error');
    }
  };

  const clearConsole = () => {
    setOutput('');
  };

  return (
    <Box width="100%" p={4} bg="gray.100">
      <VStack spacing={4} align="stretch">
        <Text fontSize="xl" fontWeight="bold">Sortie de la Console</Text>
        <Box
          bg="white"
          color="black"
          p={2}
          borderRadius="md"
          height="calc(50vh - 150px)"
          overflowY="auto"
        >
          <pre>{output}</pre>
        </Box>
        <HStack>
          <Input
            placeholder="Entrez une commande"
            value={command}
            onChange={(e) => setCommand(e.target.value)}
          />
          <Button colorScheme="blue" onClick={executeCommand}>Exécuter</Button>
        </HStack>
        <Button colorScheme="red" onClick={clearConsole}>Effacer la Console</Button>
      </VStack>
    </Box>
  );
};


---------
/// my-low-code-app/frontend/src/components/ErrorBoundary.tsx

// frontend/src/components/ErrorBoundary.tsx

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Box, Text, Button } from '@chakra-ui/react';
import { useAlert } from '../contexts/AlertContext';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <Box p={4} bg="red.100" color="red.800" borderRadius="md">
          <Text fontSize="xl" fontWeight="bold">Oops, there was an error!</Text>
          <Text mt={2}>{this.state.error?.message}</Text>
          <Button
            mt={4}
            colorScheme="red"
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try again
          </Button>
        </Box>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


---------
/// my-low-code-app/frontend/src/components/GraphCanvas.tsx

// frontend/src/components/GraphCanvas.tsx

import React, { useCallback, useState, useRef, useEffect } from 'react';
import ReactFlow, {
    Background,
    Controls,
    MiniMap,
    applyNodeChanges,
    applyEdgeChanges,
    NodeChange,
    EdgeChange,
    Connection,
    Node,
    Edge,
    useReactFlow, // **Import ajouté ici**
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Box, Button, Input, VStack, HStack, Text, Select } from '@chakra-ui/react';
import { useCombined } from '../contexts/CombinedContext';
import CodeNode from './CodeNode';
import { useModal } from '../contexts/ModalContext';
import { useAlert } from '../contexts/AlertContext';
import axiosInstance from '../axiosInstance';

const nodeTypes = {
    code: CodeNode,
};

const UPDATE_DELAY = 1000; // Délai en millisecondes avant la mise à jour

export const GraphCanvas: React.FC = () => {
    const {
      nodes,
      edges,
      updateGraph,
      addNode,
      deleteNode,
      cloneNode,
      executeNode,
      selectedProject,
      loadGraph,
    } = useCombined();
    const [selectedConnection, setSelectedConnection] = useState<Connection | null>(null);
    const { openModal, closeModal, setModalContent } = useModal();
    const [searchTerm, setSearchTerm] = useState('');
    const { fitView } = useReactFlow(); // Utilisation de useReactFlow après l'importation correcte
    const { showAlert } = useAlert();

    const [nodesState, setNodesState] = useState<Node[]>(nodes);
    const [edgesState, setEdgesState] = useState<Edge[]>(edges);
    const updateTimerRef = useRef<NodeJS.Timeout | null>(null);

    useEffect(() => {
        setNodesState(nodes);
        setEdgesState(edges);
    }, [nodes, edges]);

    const refreshGraph = useCallback(async () => {
        if (selectedProject) {
            try {
                await loadGraph(selectedProject);
                showAlert('Graphe rafraîchi avec succès', 'success');
            } catch (error) {
                console.error('Erreur lors du rafraîchissement du graphe:', error);
                showAlert('Échec du rafraîchissement du graphe', 'error');
            }
        }
    }, [selectedProject, loadGraph, showAlert]);

    useEffect(() => {
        if (selectedProject) {
            console.log("Rafraîchissement du graphe pour le projet:", selectedProject);
            refreshGraph();
        }
    }, [selectedProject]);

    const scheduleUpdate = useCallback((updatedNodes: Node[], updatedEdges: Edge[]) => {
        if (updateTimerRef.current) {
            clearTimeout(updateTimerRef.current);
        }
        updateTimerRef.current = setTimeout(async () => {
            try {
                await updateGraph(updatedNodes, updatedEdges);
                await refreshGraph();
                showAlert('Graphe mis à jour et rafraîchi', 'success');
            } catch (error) {
                console.error('Erreur lors de la mise à jour du graphe:', error);
                showAlert('Échec de la mise à jour du graphe', 'error');
            }
        }, UPDATE_DELAY);
    }, [updateGraph, refreshGraph, showAlert]);

    const onNodesChangeCallback = useCallback(
        (changes: NodeChange[]) => {
            const updatedNodes = applyNodeChanges(changes, nodesState);
            setNodesState(updatedNodes);
            scheduleUpdate(updatedNodes, edgesState);
        },
        [nodesState, edgesState, scheduleUpdate]
    );

    const onEdgesChangeCallback = useCallback(
        (changes: EdgeChange[]) => {
            const updatedEdges = applyEdgeChanges(changes, edgesState);
            setEdgesState(updatedEdges);
            scheduleUpdate(nodesState, updatedEdges);
        },
        [edgesState, nodesState, scheduleUpdate]
    );

    const onConnect = useCallback(
        (connection: Connection) => {
            setSelectedConnection(connection);
            setModalContent(
                'delete', // ou 'connect', selon votre implémentation
                { nodeId: connection.source }
            );
            openModal('delete', { nodeId: connection.source });
        },
        [openModal, setModalContent]
    );

    const handleAddNode = useCallback(() => {
        const newFileName = `newFile_${Date.now()}.js`;
        const newNode: Node = {
            id: newFileName,
            type: 'code',
            position: { x: Math.random() * 500, y: Math.random() * 500 },
            data: { code: '// New node', fileName: newFileName, imports: [], exportedFunctions: [] },
        };
        addNode(newNode);
    }, [addNode]);

    const handleSearch = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(event.target.value);
    }, []);

    const focusNode = useCallback((nodeId: string) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node) {
            fitView({ nodes: [node], duration: 800 });
        }
    }, [nodes, fitView]);

    const onEdgeClick = useCallback(
        (event: React.MouseEvent, edge: Edge) => {
            event.stopPropagation();
            setModalContent('delete', { edgeId: edge.id });
            openModal('delete', { edgeId: edge.id });
        },
        [openModal, setModalContent]
    );

    const handleDeleteEdge = useCallback((edgeId: string) => {
        const updatedEdges = edgesState.filter((e) => e.id !== edgeId);
        setEdgesState(updatedEdges);
        scheduleUpdate(nodesState, updatedEdges);
        closeModal();
    }, [edgesState, nodesState, scheduleUpdate, closeModal]);

    const filteredNodes = React.useMemo(() => {
        return nodesState.filter(node =>
            node.data.fileName.toLowerCase().includes(searchTerm.toLowerCase()) ||
            node.data.code.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [nodesState, searchTerm]);

    return (
        <Box width="60%" height="100%" position="relative">
            <ReactFlow
                nodes={nodesState}
                edges={edgesState}
                onNodesChange={onNodesChangeCallback}
                onEdgesChange={onEdgesChangeCallback}
                onConnect={onConnect}
                nodeTypes={nodeTypes}
                onEdgeClick={onEdgeClick}
                fitView
                panOnScroll
                elementsSelectable
                nodesDraggable
            >
                <Background />
                <Controls />
                <MiniMap />
            </ReactFlow>
            <VStack position="absolute" top={4} left={4} spacing={2} align="stretch">
                <Input
                    placeholder="Rechercher des nœuds..."
                    value={searchTerm}
                    onChange={handleSearch}
                    bg="white"
                    width="200px"
                />
                {searchTerm && (
                    <Box bg="white" borderRadius="md" p={2} maxHeight="200px" overflowY="auto">
                        {filteredNodes.map(node => (
                            <HStack key={node.id} justify="space-between" p={1} _hover={{ bg: "gray.100" }}>
                                <Text>{node.data.fileName}</Text>
                                <Button size="sm" onClick={() => focusNode(node.id)}>Focus</Button>
                            </HStack>
                        ))}
                    </Box>
                )}
            </VStack>
            <Button position="absolute" bottom={4} left={4} colorScheme="teal" onClick={handleAddNode}>
                Ajouter Nœud
            </Button>
            <Button
                position="absolute"
                bottom={4}
                right={4}
                colorScheme="blue"
                onClick={() => scheduleUpdate(nodesState, edgesState)}
            >
                Sauvegarder tout
            </Button>
            <Button
                position="absolute"
                bottom={16}
                right={4}
                colorScheme="green"
                onClick={refreshGraph}
            >
                Rafraîchir le graphe
            </Button>
        </Box>
    );
};


---------
/// my-low-code-app/frontend/src/components/Header.tsx

import React from 'react';
import { Box, Flex, Text, Button } from '@chakra-ui/react';
import { useAuth } from '../contexts/AuthContext';
import { useModal } from '../contexts/ModalContext';
import { useAlert } from '../contexts/AlertContext';

export const Header: React.FC = () => {
  const { isAuthenticated, logout } = useAuth();
  const { openModal } = useModal();
  const { showAlert } = useAlert();

  const handleLogout = () => {
    logout();
    showAlert('Déconnecté avec succès.', 'info');
  };

  return (
    <Flex bg="teal.500" color="white" p={4} align="center" justify="space-between">
      <Text fontSize="lg" fontWeight="bold">Low-Code App</Text>
      {isAuthenticated && (
        <Button colorScheme="red" size="sm" onClick={handleLogout}>
          Déconnexion
        </Button>
      )}
    </Flex>
  );
};


---------
/// my-low-code-app/frontend/src/components/ImportExportManager.tsx

import React, { useState } from 'react';
import { Box, VStack, HStack, Input, Button, Text, List, ListItem, IconButton } from '@chakra-ui/react';
import { AddIcon, DeleteIcon } from '@chakra-ui/icons';

interface ImportExportManagerProps {
  imports: Array<{ from: string; items: string[] }>;
  exports: string[];
  onImportsChange: (imports: Array<{ from: string; items: string[] }>) => void;
  onExportsChange: (exports: string[]) => void;
}

const ImportExportManager: React.FC<ImportExportManagerProps> = ({
  imports,
  exports,
  onImportsChange,
  onExportsChange,
}) => {
  const [newImportFrom, setNewImportFrom] = useState('');
  const [newImportItem, setNewImportItem] = useState('');
  const [newExport, setNewExport] = useState('');

  const handleAddImport = () => {
    if (newImportFrom && newImportItem) {
      const existingImport = imports.find(imp => imp.from === newImportFrom);
      if (existingImport) {
        existingImport.items.push(newImportItem);
      } else {
        imports.push({ from: newImportFrom, items: [newImportItem] });
      }
      onImportsChange([...imports]);
      setNewImportFrom('');
      setNewImportItem('');
    }
  };

  const handleRemoveImport = (from: string, item: string) => {
    const updatedImports = imports.map(imp => {
      if (imp.from === from) {
        return { ...imp, items: imp.items.filter(i => i !== item) };
      }
      return imp;
    }).filter(imp => imp.items.length > 0);
    onImportsChange(updatedImports);
  };

  const handleAddExport = () => {
    if (newExport && !exports.includes(newExport)) {
      onExportsChange([...exports, newExport]);
      setNewExport('');
    }
  };

  const handleRemoveExport = (item: string) => {
    onExportsChange(exports.filter(exp => exp !== item));
  };

  return (
    <Box>
      <VStack align="stretch" spacing={4}>
        <Box>
          <Text fontWeight="bold">Imports:</Text>
          <List spacing={2}>
            {imports.map((imp, index) => (
              <ListItem key={index}>
                <Text>From: {imp.from}</Text>
                <List pl={4}>
                  {imp.items.map((item, itemIndex) => (
                    <ListItem key={itemIndex}>
                      <HStack>
                        <Text>{item}</Text>
                        <IconButton
                          aria-label="Remove import"
                          icon={<DeleteIcon />}
                          size="xs"
                          onClick={() => handleRemoveImport(imp.from, item)}
                        />
                      </HStack>
                    </ListItem>
                  ))}
                </List>
              </ListItem>
            ))}
          </List>
          <HStack mt={2}>
            <Input
              placeholder="From module"
              value={newImportFrom}
              onChange={(e) => setNewImportFrom(e.target.value)}
            />
            <Input
              placeholder="Import item"
              value={newImportItem}
              onChange={(e) => setNewImportItem(e.target.value)}
            />
            <Button onClick={handleAddImport}>
              <AddIcon />
            </Button>
          </HStack>
        </Box>
        <Box>
          <Text fontWeight="bold">Exports:</Text>
          <List spacing={2}>
            {exports.map((exp, index) => (
              <ListItem key={index}>
                <HStack>
                  <Text>{exp}</Text>
                  <IconButton
                    aria-label="Remove export"
                    icon={<DeleteIcon />}
                    size="xs"
                    onClick={() => handleRemoveExport(exp)}
                  />
                </HStack>
              </ListItem>
            ))}
          </List>
          <HStack mt={2}>
            <Input
              placeholder="Export item"
              value={newExport}
              onChange={(e) => setNewExport(e.target.value)}
            />
            <Button onClick={handleAddExport}>
              <AddIcon />
            </Button>
          </HStack>
        </Box>
      </VStack>
    </Box>
  );
};

export default ImportExportManager;

---------
/// my-low-code-app/frontend/src/components/LoginModal.tsx

import React, { useState } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Input,
  VStack,
  Text,
} from '@chakra-ui/react';
import { useModal } from '../contexts/ModalContext';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const LoginModal: React.FC = () => {
  const { isOpen, closeModal, modalContent } = useModal();
  const { login } = useAuth();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleLogin = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await login(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  // Vérifiez si le modal actuel est le LoginModal
  if (modalContent !== 'login') return null;

  return (
    <Modal isOpen={isOpen} onClose={closeModal}>
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Connexion</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4}>
            <Input
              placeholder="Nom d'utilisateur"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            <Input
              type="password"
              placeholder="Mot de passe"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </VStack>
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="blue" mr={3} onClick={handleLogin} isLoading={isSubmitting}>
            Connexion
          </Button>
          <Button variant="ghost" onClick={() => {
            closeModal();
            // Optionnel : Ouvrir le RegisterModal si nécessaire
          }}>
            Annuler
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};


---------
/// my-low-code-app/frontend/src/components/MainApp.tsx

import React from 'react';
import { Box, Flex } from '@chakra-ui/react';
import { Sidebar } from './Sidebar';
import { GraphCanvas } from './GraphCanvas';
import { Console } from './Console';
import { ProjectStructure } from './ProjectStructure';

export const MainApp: React.FC = () => {
  return (
    <Flex height="calc(100vh - 60px)"> {/* Ajustez la hauteur en fonction de votre en-tête */}
      <Sidebar />
      <Box flex={1} display="flex">
        <GraphCanvas />
        <Box width="40%" display="flex" flexDirection="column">
          <ProjectStructure />
          <Console />
        </Box>
      </Box>
    </Flex>
  );
};

---------
/// my-low-code-app/frontend/src/components/Modals.tsx

// frontend/src/components/Modals.tsx

import React from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Text,
  useDisclosure,
} from '@chakra-ui/react';
import { useGraph } from '../contexts/GraphContext';

export const Modals: React.FC = () => {
  const { isOpen: isDeleteModalOpen, onOpen: onDeleteModalOpen, onClose: onDeleteModalClose } = useDisclosure();
  const { deleteNode } = useGraph();
  const [nodeToDelete, setNodeToDelete] = React.useState<string | null>(null);

  // This function would be called from a parent component or through an event system
  const openDeleteModal = (nodeId: string) => {
    setNodeToDelete(nodeId);
    onDeleteModalOpen();
  };

  const handleConfirmDelete = () => {
    if (nodeToDelete) {
      deleteNode(nodeToDelete);
      onDeleteModalClose();
      setNodeToDelete(null);
    }
  };

  return (
    <>
      {/* Delete Node Modal */}
      <Modal isOpen={isDeleteModalOpen} onClose={onDeleteModalClose}>
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Confirm Deletion</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            <Text>Are you sure you want to delete this node? This action cannot be undone.</Text>
          </ModalBody>
          <ModalFooter>
            <Button colorScheme="red" mr={3} onClick={handleConfirmDelete}>
              Delete
            </Button>
            <Button variant="ghost" onClick={onDeleteModalClose}>Cancel</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* You can add more modals here as needed */}
      {/* For example: Edit Node Modal, Create Connection Modal, etc. */}
    </>
  );
};

// This function should be exported and used in parent components to open the delete modal
export const useModals = () => {
  const { isOpen: isDeleteModalOpen, onOpen: onDeleteModalOpen, onClose: onDeleteModalClose } = useDisclosure();

  const openDeleteModal = (nodeId: string) => {
    // Logic to set the node to delete and open the modal
    onDeleteModalOpen();
  };

  return {
    openDeleteModal,
    isDeleteModalOpen,
    onDeleteModalClose,
  };
};

---------
/// my-low-code-app/frontend/src/components/ProjectControls.tsx

import React from 'react';
import { Button, HStack } from '@chakra-ui/react';
import axiosInstance from '../axiosInstance';
import { useProject } from '../contexts/ProjectContext';
import { useAlert } from '../contexts/AlertContext';

export const ProjectControls: React.FC = () => {
  const { selectedProject } = useProject();
  const { showAlert } = useAlert();

  const handleCommit = async () => {
    try {
      await axiosInstance.post('/git/commit', {
        project: selectedProject,
        message: 'Commit via Low-Code Interface',
      });
      showAlert('Modifications commitées avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du commit: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  const handlePush = async () => {
    try {
      await axiosInstance.post('/git/push', {
        project: selectedProject,
      });
      showAlert('Modifications poussées vers GitHub avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du push: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  const handlePull = async () => {
    try {
      await axiosInstance.post('/git/pull', {
        project: selectedProject,
      });
      showAlert('Modifications récupérées depuis GitHub avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du pull: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  return (
    <HStack spacing={4}>
      <Button colorScheme="yellow" onClick={handleCommit}>
        Commit
      </Button>
      <Button colorScheme="green" onClick={handlePush}>
        Push
      </Button>
      <Button colorScheme="blue" onClick={handlePull}>
        Pull
      </Button>
    </HStack>
  );
};


---------
/// my-low-code-app/frontend/src/components/ProjectStructure.tsx

// frontend/src/components/ProjectStructure.tsx

import React from 'react';
import { Box, Text, VStack, HStack, Icon } from '@chakra-ui/react';
import { FaFolder, FaFile } from 'react-icons/fa';
import { useGraph } from '../contexts/GraphContext';

interface FileTreeNode {
  name: string;
  type: 'file' | 'folder';
  children?: FileTreeNode[];
}

const FileTreeItem: React.FC<{ node: FileTreeNode; depth: number }> = ({ node, depth }) => {
  return (
    <VStack align="start" pl={depth * 4} spacing={1}>
      <HStack>
        <Icon as={node.type === 'folder' ? FaFolder : FaFile} color={node.type === 'folder' ? 'yellow.500' : 'blue.500'} />
        <Text>{node.name}</Text>
      </HStack>
      {node.children && node.children.map((child, index) => (
        <FileTreeItem key={index} node={child} depth={depth + 1} />
      ))}
    </VStack>
  );
};

export const ProjectStructure: React.FC = () => {
  const { nodes } = useGraph();

  const fileTree: FileTreeNode = {
    name: 'Project Root',
    type: 'folder',
    children: nodes.map(node => ({
      name: node.data.fileName,
      type: 'file'
    }))
  };

  return (
    <Box width="100%" p={4} bg="gray.50" overflowY="auto" height="50vh">
      <Text fontSize="xl" fontWeight="bold" mb={4}>Project Structure</Text>
      <FileTreeItem node={fileTree} depth={0} />
    </Box>
  );
};

---------
/// my-low-code-app/frontend/src/components/ProtectedRoute.tsx

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // Redirect to the login page with the current location as state
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

---------
/// my-low-code-app/frontend/src/components/RegisterModal.tsx

// frontend/src/components/RegisterModal.tsx

import React, { useState } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Input,
  VStack,
  Text,
} from '@chakra-ui/react';
import { useModal } from '../contexts/ModalContext';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const RegisterModal: React.FC = () => {
  const { isOpen, closeModal, modalContent } = useModal();
  const { register } = useAuth();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleRegister = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await register(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  // Vérifiez si le modal actuel est le RegisterModal
  if (modalContent !== 'register') return null;

  return (
    <Modal isOpen={isOpen} onClose={closeModal}>
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Inscription</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4}>
            <Input
              placeholder="Nom d'utilisateur"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            <Input
              type="password"
              placeholder="Mot de passe"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </VStack>
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="green" mr={3} onClick={handleRegister} isLoading={isSubmitting}>
            Inscription
          </Button>
          <Button variant="ghost" onClick={() => {
            closeModal();
            // Optionnel : Ouvrir le LoginModal si nécessaire
          }}>
            Annuler
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};


---------
/// my-low-code-app/frontend/src/components/Sidebar.tsx

// frontend/src/components/Sidebar.tsx

import React, { useState, useCallback } from 'react';
import {
  Box,
  VStack,
  Input,
  Button,
  Select,
  Text,
  HStack,
} from '@chakra-ui/react';
import { AddIcon } from '@chakra-ui/icons';
import { useCombined } from '../contexts/CombinedContext'; // Utiliser useCombined
import { useAlert } from '../contexts/AlertContext';
import { ProjectControls } from './ProjectControls';
import { useAuth } from '../contexts/AuthContext';
import { useModal } from '../contexts/ModalContext';

export const Sidebar: React.FC = () => {
  const {
    projects,
    selectedProject,
    selectProject,
    createProject,
    installPackage,
    importGitProject,
    deleteProject,
  } = useCombined(); // Utiliser useCombined
  const [newProjectCode, setNewProjectCode] = useState('');
  const [newProjectName, setNewProjectName] = useState('');
  const [packageName, setPackageName] = useState('');
  const [gitRepoUrl, setGitRepoUrl] = useState('');
  const { showAlert } = useAlert();
  const { isAuthenticated, logout } = useAuth();
  const { openModal } = useModal();

  const handleCreateProject = async () => {
    if (newProjectCode && newProjectName) {
      try {
        await createProject(newProjectCode, newProjectName);
        setNewProjectCode('');
        setNewProjectName('');
        showAlert('Projet créé avec succès.', 'success');
      } catch (error: any) {
        showAlert(
          `Erreur lors de la création du projet: ${error.response?.data?.message || error.message}`,
          'error'
        );
      }
    } else {
      showAlert('Code et nom du projet sont requis.', 'warning');
    }
  };

  const handleSelectProject = async (projectName: string) => {
    selectProject(projectName);
    showAlert(`Projet "${projectName}" sélectionné.`, 'info');
  };

  const handleInstallPackage = async () => {
    if (packageName) {
      try {
        await installPackage(packageName);
        setPackageName('');
        showAlert(`Package "${packageName}" installé avec succès.`, 'success');
      } catch (error: any) {
        showAlert(
          `Erreur lors de l'installation du package: ${error.response?.data?.message || error.message}`,
          'error'
        );
      }
    } else {
      showAlert('Nom du package requis.', 'warning');
    }
  };

  const handleGitPull = async () => {
    if (!gitRepoUrl) {
      showAlert("L'URL du dépôt Git est requise.", 'warning');
      return;
    }

    try {
      await importGitProject(gitRepoUrl);
      showAlert('Projet Git importé avec succès.', 'success');
      setGitRepoUrl('');
    } catch (error: any) {
      showAlert(`Erreur lors de l'importation du projet Git: ${error.message}`, 'error');
    }
  };

  const handleDeleteProject = async (projectName: string) => {
    if (window.confirm(`Êtes-vous sûr de vouloir supprimer le projet "${projectName}" ?`)) {
      try {
        await deleteProject(projectName);
        showAlert(`Projet "${projectName}" supprimé avec succès.`, 'success');
      } catch (error: any) {
        showAlert(`Erreur lors de la suppression du projet: ${error.message}`, 'error');
      }
    }
  };

  const handleLogout = () => {
    logout();
    showAlert('Déconnecté avec succès.', 'info');
  };

  return (
    <Box width="20%" p={4} bg="gray.100" overflowY="auto" height="100vh">
      <VStack spacing={6} align="stretch">
        <Text fontSize="2xl" fontWeight="bold" textAlign="center">
          Gestion de Projet
        </Text>

        {isAuthenticated ? (
          <>
            <VStack align="stretch" spacing={2}>
              <Input
                placeholder="Code du Projet"
                value={newProjectCode}
                onChange={(e) => setNewProjectCode(e.target.value)}
              />
              <Input
                placeholder="Nom du Projet"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
              />
              <Button
                colorScheme="teal"
                leftIcon={<AddIcon />}
                onClick={handleCreateProject}
              >
                Créer Projet
              </Button>
            </VStack>

            <Select
              placeholder="Sélectionner un Projet"
              value={selectedProject}
              onChange={(e) => handleSelectProject(e.target.value)}
            >
              {projects.map((project) => (
                <option key={project._id} value={project.name}>
                  {project.name}
                </option>
              ))}
            </Select>

            {selectedProject && (
              <>
                <VStack align="stretch" spacing={2}>
                  <Input
                    placeholder="Nom du Package"
                    value={packageName}
                    onChange={(e) => setPackageName(e.target.value)}
                  />
                  <Button
                    colorScheme="blue"
                    leftIcon={<AddIcon />}
                    onClick={handleInstallPackage}
                  >
                    Installer Package
                  </Button>
                </VStack>
                <Button
                  colorScheme="red"
                  onClick={() => handleDeleteProject(selectedProject)}
                >
                  Supprimer le projet
                </Button>
              </>
            )}

            <VStack align="stretch" spacing={2}>
              <Input
                placeholder="URL du dépôt Git"
                value={gitRepoUrl}
                onChange={(e) => setGitRepoUrl(e.target.value)}
              />
              <Button
                colorScheme="purple"
                onClick={handleGitPull}
              >
                Importer depuis Git
              </Button>
            </VStack>

            <ProjectControls />

            <Button colorScheme="red" onClick={handleLogout}>
              Déconnexion
            </Button>
          </>
        ) : (
          <VStack align="stretch" spacing={2}>
            <Button colorScheme="blue" onClick={() => openModal('login')}>
              Connexion
            </Button>
            <Button colorScheme="green" onClick={() => openModal('register')}>
              Inscription
            </Button>
          </VStack>
        )}
      </VStack>
    </Box>
  );
};


---------
/// my-low-code-app/frontend/src/components/SimpleModal.tsx



---------
/// my-low-code-app/frontend/src/contexts/AlertContext.tsx

// frontend/src/contexts/AlertContext.tsx

import React, { createContext, useState, useContext, ReactNode } from 'react';
import { useToast } from '@chakra-ui/react';

interface AlertContextType {
  showAlert: (message: string, status: 'success' | 'error' | 'info' | 'warning') => void;
}

const AlertContext = createContext<AlertContextType | undefined>(undefined);

export const AlertProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const toast = useToast();

  const showAlert = (message: string, status: 'success' | 'error' | 'info' | 'warning') => {
    toast({
      title: message,
      status: status,
      duration: 3000,
      isClosable: true,
    });
  };

  return (
    <AlertContext.Provider value={{ showAlert }}>
      {children}
    </AlertContext.Provider>
  );
};

export const useAlert = () => {
  const context = useContext(AlertContext);
  if (context === undefined) {
    throw new Error('useAlert must be used within an AlertProvider');
  }
  return context;
};

---------
/// my-low-code-app/frontend/src/contexts/AuthContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';

interface AuthContextType {
  isAuthenticated: boolean;
  token: string | null;
  login: (username: string, password: string) => Promise<void>;
  register: (username: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [token, setToken] = useState<string | null>(() => localStorage.getItem('token'));
  const { showAlert } = useAlert();

  useEffect(() => {
    if (token) {
      localStorage.setItem('token', token);
    } else {
      localStorage.removeItem('token');
    }
  }, [token]);

  const login = async (username: string, password: string) => {
    try {
      const response = await axiosInstance.post('/auth/login', { username, password });
      setToken(response.data.token);
      showAlert('Connexion réussie.', 'success');
    } catch (error: any) {
      const message = error.response?.data?.message || 'Échec de la connexion.';
      showAlert(message, 'error');
      throw error;
    }
  };

  const register = async (username: string, password: string) => {
    try {
      await axiosInstance.post('/auth/register', { username, password });
      showAlert('Inscription réussie. Vous pouvez maintenant vous connecter.', 'success');
    } catch (error: any) {
      const message = error.response?.data?.message || 'Échec de l\'inscription.';
      showAlert(message, 'error');
      throw error;
    }
  };

  const logout = () => {
    setToken(null);
    showAlert('Déconnexion réussie.', 'info');
  };

  const isAuthenticated = Boolean(token);

  return (
    <AuthContext.Provider value={{ isAuthenticated, token, login, register, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth doit être utilisé dans un AuthProvider');
  }
  return context;
};


---------
/// my-low-code-app/frontend/src/contexts/CombinedContext.tsx

// frontend/src/contexts/CombinedContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import { Node, Edge } from 'reactflow';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';
import { useGraph } from './GraphContext';
import { useProject } from './ProjectContext';

interface Project {
  _id: string;
  name: string;
  createdAt: string;
}

interface CombinedContextType {
  projects: Project[];
  selectedProject: string;
  nodes: Node[];
  edges: Edge[];
  loadProjects: () => Promise<void>;
  selectProject: (project: string) => void;
  createProject: (projectCode: string, projectName: string) => Promise<void>;
  installPackage: (packageName: string) => Promise<void>;
  importGitProject: (repoUrl: string) => Promise<void>;
  deleteProject: (projectName: string) => Promise<void>;
  loadGraph: () => Promise<void>;
  updateGraph: (updatedNodes: Node[], updatedEdges: Edge[]) => Promise<void>;
  addNode: (newNode: Node) => void;
  deleteNode: (nodeId: string) => Promise<void>;
  cloneNode: (nodeId: string) => Promise<void>;
  executeNode: (nodeId: string) => Promise<{ stdout: string; stderr: string }>;
}

const CombinedContext = createContext<CombinedContextType | undefined>(undefined);

export const CombinedProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { projects, selectedProject, selectProject, loadProjects, createProject, installPackage, importGitProject, deleteProject } = useProject();
  const { nodes, edges, loadGraph, updateGraph, addNode, deleteNode, cloneNode, executeNode } = useGraph();
  const { showAlert } = useAlert();

  // Charger le graphe lorsque le projet sélectionné change
  useEffect(() => {
    if (selectedProject) {
      loadGraph(selectedProject);
    }
  }, [selectedProject, loadGraph]);

  const handleUpdateGraph = async (updatedNodes: Node[], updatedEdges: Edge[]) => {
    try {
      await updateGraph(selectedProject, updatedNodes, updatedEdges);
    } catch (error) {
      // L'erreur est déjà gérée dans GraphProvider
    }
  };

  const contextValue: CombinedContextType = {
    projects,
    selectedProject,
    nodes,
    edges,
    loadProjects,
    selectProject,
    createProject,
    installPackage,
    importGitProject,
    deleteProject,
    loadGraph: () => loadGraph(selectedProject),
    updateGraph: handleUpdateGraph,
    addNode,
    deleteNode,
    cloneNode,
    executeNode
  };

  return (
    <CombinedContext.Provider value={contextValue}>
      {children}
    </CombinedContext.Provider>
  );
};

export const useCombined = () => {
  const context = useContext(CombinedContext);
  if (!context) {
    throw new Error('useCombined must be used within a CombinedProvider');
  }
  return context;
};


---------
/// my-low-code-app/frontend/src/contexts/GraphContext.tsx

// frontend/src/contexts/GraphContext.tsx

import React, { createContext, useState, useContext, ReactNode, useCallback } from 'react';
import { Node, Edge } from 'reactflow';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';

interface GraphContextType {
  nodes: Node[];
  edges: Edge[];
  loadGraph: (project: string) => Promise<void>;
  updateGraph: (project: string, updatedNodes: Node[], updatedEdges: Edge[]) => Promise<void>;
  addNode: (newNode: Node) => void;
  deleteNode: (nodeId: string) => Promise<void>;
  cloneNode: (nodeId: string) => Promise<void>;
  executeNode: (nodeId: string) => Promise<{ stdout: string; stderr: string }>;
}

const GraphContext = createContext<GraphContextType | undefined>(undefined);

export const GraphProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const { showAlert } = useAlert();

  const loadGraph = useCallback(async (project: string) => {
    try {
      const response = await axiosInstance.get('/project-graph', {
        params: { project },
      });
      setNodes(response.data.graph.nodes);
      setEdges(response.data.graph.edges);
      showAlert('Graphe chargé avec succès.', 'success');
    } catch (error) {
      console.error('Échec du chargement du graphe du projet:', error);
      showAlert('Échec du chargement du graphe du projet.', 'error');
    }
  }, [showAlert]);

  const updateGraph = async (project: string, updatedNodes: Node[], updatedEdges: Edge[]) => {
    try {
      const response = await axiosInstance.post('/project-graph/update-graph', {
        project,
        nodes: updatedNodes,
        edges: updatedEdges
      });
      console.log('Réponse de mise à jour du graphe:', response.data);
      setNodes(updatedNodes);
      setEdges(updatedEdges);
      showAlert('Graphe mis à jour avec succès.', 'success');
    } catch (error) {
      console.error('Échec de la mise à jour du graphe:', error);
      showAlert('Échec de la mise à jour du graphe.', 'error');
      throw error;
    }
  };

  const addNode = (newNode: Node) => {
    setNodes(prevNodes => [...prevNodes, newNode]);
  };

  const deleteNode = async (nodeId: string) => {
    try {
      const response = await axiosInstance.post('/project-graph/delete-node', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId
      });
      console.log('Réponse de suppression du nœud:', response.data);
      setNodes(prevNodes => prevNodes.filter(node => node.id !== nodeId));
      setEdges(prevEdges => prevEdges.filter(edge => edge.source !== nodeId && edge.target !== nodeId));
      showAlert('Nœud supprimé avec succès.', 'success');
    } catch (error) {
      console.error('Échec de la suppression du nœud:', error);
      showAlert('Échec de la suppression du nœud.', 'error');
      throw error;
    }
  };

  const cloneNode = async (nodeId: string) => {
    try {
      const newNodeId = `${nodeId}_clone`;
      const response = await axiosInstance.post('/project-graph/clone-node', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId,
        newNodeId
      });
      console.log('Réponse de clonage du nœud:', response.data);
      setNodes(prevNodes => [...prevNodes, response.data.clonedNode]);
      showAlert('Nœud cloné avec succès.', 'success');
    } catch (error) {
      console.error('Échec du clonage du nœud:', error);
      showAlert('Échec du clonage du nœud.', 'error');
      throw error;
    }
  };

  const executeNode = async (nodeId: string): Promise<{ stdout: string; stderr: string }> => {
    try {
      const response = await axiosInstance.post('/execute', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId
      });
      console.log('Réponse d\'exécution du nœud:', response.data);
      showAlert('Nœud exécuté avec succès.', 'success');
      return { stdout: response.data.stdout, stderr: response.data.stderr };
    } catch (error) {
      console.error('Échec de l\'exécution du nœud:', error);
      showAlert('Échec de l\'exécution du nœud.', 'error');
      throw error;
    }
  };

  return (
    <GraphContext.Provider value={{ nodes, edges, loadGraph, updateGraph, addNode, deleteNode, cloneNode, executeNode }}>
      {children}
    </GraphContext.Provider>
  );
};

export const useGraph = () => {
  const context = useContext(GraphContext);
  if (!context) {
    throw new Error('useGraph doit être utilisé à l\'intérieur d\'un GraphProvider');
  }
  return context;
};


---------
/// my-low-code-app/frontend/src/contexts/ModalContext.tsx

// frontend/src/contexts/ModalContext.tsx

import React, { createContext, useState, useContext, ReactNode } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  VStack,
  Text,
  HStack,
} from '@chakra-ui/react';
import { useCombined } from './CombinedContext';
import { useAlert } from './AlertContext';

interface ModalContextType {
  isOpen: boolean;
  openModal: (content: string, data?: any) => void;
  closeModal: () => void;
  modalContent: string | null;
  modalData: any;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export const ModalProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<string | null>(null);
  const [modalData, setModalData] = useState<any>(null);
  const { deleteNode } = useCombined();
  const { showAlert } = useAlert();

  const openModal = (content: string, data: any = null) => {
    setModalContent(content);
    setModalData(data);
    setIsOpen(true);
    console.log(`Modal ouvert: ${content}`, data); // Debug
  };

  const closeModal = () => {
    setIsOpen(false);
    setModalContent(null);
    setModalData(null);
    console.log('Modal fermé'); // Debug
  };

  const handleDelete = async () => {
    if (modalData && modalData.nodeId) {
      try {
        await deleteNode(modalData.nodeId);
        showAlert('Nœud supprimé avec succès.', 'success');
        closeModal();
      } catch (error: any) {
        showAlert('Échec de la suppression du nœud.', 'error');
      }
    }
  };

  const renderModalContent = () => {
    switch (modalContent) {
      case 'login':
        return <LoginForm />;
      case 'register':
        return <RegisterForm />;
      case 'delete':
        return <DeleteNodeForm />;
      // Ajoutez d'autres cas pour différents types de modaux
      default:
        return null;
    }
  };

  return (
    <ModalContext.Provider value={{ isOpen, openModal, closeModal, modalContent, modalData }}>
      {children}
      {isOpen && (
        <Modal isOpen={isOpen} onClose={closeModal} isCentered>
          <ModalOverlay />
          <ModalContent>
            <ModalHeader>
              {modalContent === 'login'
                ? 'Connexion'
                : modalContent === 'register'
                ? 'Inscription'
                : 'Confirmation'}
            </ModalHeader>
            <ModalCloseButton />
            <ModalBody>{renderModalContent()}</ModalBody>
            <ModalFooter>
              {modalContent !== 'delete' && (
                <Button colorScheme="blue" mr={3} onClick={closeModal}>
                  Fermer
                </Button>
              )}
            </ModalFooter>
          </ModalContent>
        </Modal>
      )}
    </ModalContext.Provider>
  );
};

// Hook personnalisé pour utiliser le contexte des modaux
export const useModal = () => {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error('useModal must be used within a ModalProvider');
  }
  return context;
};

// Composant pour le formulaire de connexion
const LoginForm: React.FC = () => {
  const { closeModal } = useModal();
  const { login } = useCombined();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleLogin = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await login(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <VStack spacing={4}>
      <Input
        placeholder="Nom d'utilisateur"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <Input
        type="password"
        placeholder="Mot de passe"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <Button colorScheme="blue" onClick={handleLogin} isLoading={isSubmitting}>
        Connexion
      </Button>
    </VStack>
  );
};

// Composant pour le formulaire d'inscription
const RegisterForm: React.FC = () => {
  const { closeModal } = useModal();
  const { register } = useCombined();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleRegister = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await register(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <VStack spacing={4}>
      <Input
        placeholder="Nom d'utilisateur"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <Input
        type="password"
        placeholder="Mot de passe"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <Button colorScheme="green" onClick={handleRegister} isLoading={isSubmitting}>
        Inscription
      </Button>
    </VStack>
  );
};

// Composant pour la confirmation de suppression de nœud
const DeleteNodeForm: React.FC = () => {
  const { closeModal, modalData } = useModal();
  const { deleteNode } = useCombined();
  const { showAlert } = useAlert();

  const handleDelete = async () => {
    if (modalData && modalData.nodeId) {
      try {
        await deleteNode(modalData.nodeId);
        showAlert('Nœud supprimé avec succès.', 'success');
        closeModal();
      } catch (error: any) {
        showAlert('Échec de la suppression du nœud.', 'error');
      }
    }
  };

  return (
    <VStack spacing={4}>
      <Text>Êtes-vous sûr de vouloir supprimer ce nœud ? Cette action est irréversible.</Text>
      <HStack spacing={4}>
        <Button colorScheme="red" onClick={handleDelete}>
          Supprimer
        </Button>
        <Button variant="ghost" onClick={closeModal}>
          Annuler
        </Button>
      </HStack>
    </VStack>
  );
};


---------
/// my-low-code-app/frontend/src/contexts/ProjectContext.tsx

// frontend/src/contexts/ProjectContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import axiosInstance from '../axiosInstance';
// Supprimer l'import de useGraph
import { useAlert } from './AlertContext';

interface Project {
  _id: string;
  name: string;
  createdAt: string;
}

interface ProjectContextType {
  projects: Project[];
  selectedProject: string;
  selectProject: (project: string) => void;
  loadProjects: () => Promise<void>;
  importGitProject: (repoUrl: string) => Promise<void>;
  deleteProject: (projectName: string) => Promise<void>;
}

const ProjectContext = createContext<ProjectContextType | undefined>(undefined);

export const ProjectProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [selectedProject, setSelectedProject] = useState<string>('');
  // Retirer l'utilisation de useGraph
  const { showAlert } = useAlert();

  const loadProjects = async () => {
    try {
      const response = await axiosInstance.get('/projects');
      setProjects(response.data);
    } catch (error: any) {
      console.error('Failed to load projects:', error);
      showAlert('Échec du chargement des projets.', 'error');
    }
  };

  const selectProject = (project: string) => {
    setSelectedProject(project);
    showAlert(`Projet "${project}" sélectionné.`, 'info');
    // loadGraph est maintenant géré ailleurs
  };

  const importGitProject = async (repoUrl: string) => {
    try {
      const response = await axiosInstance.post("/git/pull", { repoUrl });
      showAlert("Projet Git importé avec succès.", "success");
      await loadProjects();
      if (response.data.projectName) {
        setSelectedProject(response.data.projectName);
      } else {
        showAlert("Le nom du projet n'a pas été trouvé dans la réponse.", "warning");
      }
    } catch (error: any) {
      console.error("Failed to import Git project:", error);
      const errorMessage =
        error.response?.data?.message || "Échec de l'importation du projet Git.";
      showAlert(errorMessage, "error");
      throw error;
    }
  };

  const deleteProject = async (projectName: string) => {
    try {
      await axiosInstance.delete(`/projects/${projectName}`);
      showAlert(`Projet "${projectName}" supprimé avec succès.`, 'success');
      await loadProjects();
      if (selectedProject === projectName) {
        setSelectedProject("");
      }
    } catch (error: any) {
      console.error("Failed to delete project:", error);
      const errorMessage =
        error.response?.data?.message || "Échec de la suppression du projet.";
      showAlert(errorMessage, "error");
      throw error;
    }
  };

  useEffect(() => {
    loadProjects();
  }, []);

  const contextValue: ProjectContextType = {
    projects,
    selectedProject,
    selectProject,
    loadProjects,
    importGitProject,
    deleteProject,
  };

  return (
    <ProjectContext.Provider value={contextValue}>
      {children}
    </ProjectContext.Provider>
  );
};

export const useProject = () => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};


---------
/// my-low-code-app/frontend/src/edges/index.ts

import type { Edge, EdgeTypes } from '@xyflow/react';

export const initialEdges: Edge[] = [
  { id: 'a->c', source: 'a', target: 'c', animated: true },
  { id: 'b->d', source: 'b', target: 'd' },
  { id: 'c->d', source: 'c', target: 'd', animated: true },
];

export const edgeTypes = {
  // Add your custom edge types here!
} satisfies EdgeTypes;

---------
/// my-low-code-app/frontend/src/hooks/useAlerts.ts

import { useState } from 'react';

export const useAlerts = () => {
  const [message, setMessage] = useState<string>('');
  const [status, setStatus] = useState<'success' | 'error' | 'info'>('info');
  const [isOpen, setIsOpen] = useState<boolean>(false);

  const showAlert = (msg: string, stat: 'success' | 'error' | 'info') => {
    setMessage(msg);
    setStatus(stat);
    setIsOpen(true);
    setTimeout(() => setIsOpen(false), 3000);
  };

  return { message, status, isOpen, showAlert };
};

---------
/// my-low-code-app/frontend/src/hooks/useProjects.ts

import { useState, useEffect } from 'react';
import axios from 'axios';

export const useProjects = () => {
  const [projects, setProjects] = useState<string[]>([]);  // Initialisation avec un tableau vide
  const [selectedProject, setSelectedProject] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const loadProjectGraph = async (project: string) => {
    try {
      setSelectedProject(project);
      const res = await axios.get(`/project-graph?project=${project}`);
      return res.data.graph;
    } catch (error) {
      console.error('Error loading project graph:', error);
    }
  };

  const createProject = async (projectCode: string, projectName: string) => {
    try {
      const res = await axios.post('/create-project', { projectCode, projectName });
      setProjects([...projects, res.data.projectPath]);
    } catch (error) {
      console.error('Error creating project:', error);
    }
  };

  const handleInstallPackage = async (packageName: string) => {
    try {
      const res = await axios.post('/install-package', { project: selectedProject, packageName });
      console.log(res.data.stdout);
    } catch (error) {
      console.error('Error installing package:', error);
    }
  };

  useEffect(() => {
    const fetchProjects = async () => {
      setIsLoading(true);
      try {
        const res = await axios.get('/projects');
        setProjects(res.data || []);  // S'assurer que les données sont un tableau
      } catch (error) {
        console.error('Error loading projects:', error);
        setProjects([]);  // Valeur par défaut en cas d'erreur
      } finally {
        setIsLoading(false);
      }
    };
    fetchProjects();
  }, []);

  return { projects, selectedProject, loadProjectGraph, createProject, handleInstallPackage, isLoading };
};

---------
/// my-low-code-app/frontend/src/main.tsx

// frontend/src/main.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { ChakraProvider } from '@chakra-ui/react';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ChakraProvider>
      <App />
    </ChakraProvider>
  </React.StrictMode>
);

---------
/// my-low-code-app/frontend/src/nodes/PositionLoggerNode.tsx

// my-low-code-app/frontend/src/nodes/PositionLoggerNode.tsx

import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Box, Text } from '@chakra-ui/react';

interface PositionLoggerNodeData {
  label: string;
}

export const PositionLoggerNode: React.FC<NodeProps<PositionLoggerNodeData>> = ({ data }) => {
  return (
    <Box
      p={4}
      borderWidth="1px"
      borderRadius="md"
      bg="white"
      boxShadow="md"
      textAlign="center"
    >
      <Text fontWeight="bold">{data.label}</Text>
      <Handle type="source" position={Position.Bottom} />
    </Box>
  );
};

---------
/// my-low-code-app/frontend/src/nodes/index.ts

// my-low-code-app/frontend/src/nodes/index.ts

import type { NodeTypes } from 'reactflow';
import { PositionLoggerNode } from './PositionLoggerNode';

export const nodeTypes = {
  'position-logger': PositionLoggerNode,
} satisfies NodeTypes;

---------
/// my-low-code-app/frontend/src/nodes/types.ts

import type { Node } from 'reactflow';

export type PositionLoggerNode = Node<{ label: string }, 'position-logger'>;
export type AppNode = PositionLoggerNode;
// Ajoutez d'autres types de nœuds ici si nécessaire

---------
/// my-low-code-app/frontend/src/pages/LoginPage.tsx

import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Box, VStack, Input, Button, Heading, Text, Link } from '@chakra-ui/react';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const LoginPage: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const { login } = useAuth();
  const { showAlert } = useAlert();
  const navigate = useNavigate();
  const location = useLocation();

  const handleLogin = async () => {
    try {
      await login(username, password);
      showAlert('Connexion réussie', 'success');
      const origin = (location.state as any)?.from?.pathname || '/';
      navigate(origin);
    } catch (error) {
      showAlert('Échec de la connexion', 'error');
    }
  };

  return (
    <Box maxWidth="400px" margin="auto" mt={8}>
      <VStack spacing={4}>
        <Heading>Connexion</Heading>
        <Input
          placeholder="Nom d'utilisateur"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Mot de passe"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button colorScheme="blue" onClick={handleLogin}>
          Se connecter
        </Button>
        <Text>
          Pas encore de compte ?{' '}
          <Link color="blue.500" onClick={() => navigate('/register')}>
            S'inscrire
          </Link>
        </Text>
      </VStack>
    </Box>
  );
};

---------
/// my-low-code-app/frontend/src/pages/RegisterPage.tsx

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, VStack, Input, Button, Heading, Text, Link, useToast } from '@chakra-ui/react';
import axios from '../axiosInstance';

export const RegisterPage: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const navigate = useNavigate();
  const toast = useToast();

  const handleRegister = async () => {
    if (!username || !password) {
      toast({
        title: "Erreur",
        description: "Nom d'utilisateur et mot de passe requis.",
        status: "warning",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    setIsSubmitting(true);
    try {
      const response = await axios.post('/auth/register', { username, password });
      toast({
        title: "Inscription réussie",
        description: response.data.message,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      navigate('/login');
    } catch (error: any) {
      toast({
        title: "Erreur d'inscription",
        description: error.response?.data?.message || "Une erreur est survenue lors de l'inscription.",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Box maxWidth="400px" margin="auto" mt={8}>
      <VStack spacing={4}>
        <Heading>Inscription</Heading>
        <Input
          placeholder="Nom d'utilisateur"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Mot de passe"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button colorScheme="green" onClick={handleRegister} isLoading={isSubmitting}>
          S'inscrire
        </Button>
        <Text>
          Déjà un compte ?{' '}
          <Link color="blue.500" onClick={() => navigate('/login')}>
            Se connecter
          </Link>
        </Text>
      </VStack>
    </Box>
  );
};

---------
/// my-low-code-app/frontend/src/utils.ts

// backend/utils.ts

import { Node, Edge } from './types';

/**
 * Function to sanitize variable names.
 * Replace all invalid characters with underscores.
 * @param name Variable name to sanitize.
 * @returns Sanitized variable name.
 */
function sanitizeVariableName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

export function compileNodes(nodes: Node[], entryNodeId: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.error(`Node with id ${nodeId} not found`);
      return;
    }

    // Add imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Add node code within a closure
    const sanitizedFileName = sanitizeVariableName(node.data.fileName);
    compiledCode += `
const ${sanitizedFileName} = (function() {
  const module = { exports: {} };
  const exports = module.exports;
  ${node.data.code}
  return module.exports;
})();
`;

    // Export functions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `if (typeof ${sanitizedFileName}.${func} === 'function') {
  globalThis.${func} = ${sanitizedFileName}.${func};
}\n`;
    });
  }

  // Start compilation from the entry node
  compileNode(entryNodeId);

  return compiledCode;
}


---------
/// my-low-code-app/frontend/src/vite-env.d.ts



/// my-low-code-app/backend/src/context.ts

// backend/src/context.ts

import { parse } from '@babel/parser';
import traverse from '@babel/traverse';

export class Context {
  [key: string]: any;

  constructor(exportedFunctions: { [key: string]: Function }) {
    for (const funcName in exportedFunctions) {
      if (exportedFunctions.hasOwnProperty(funcName)) {
        this[funcName] = exportedFunctions[funcName];
      }
    }
  }

  static extractExportedFunctions(code: string): string[] {
    const exportedFunctions: string[] = [];
    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      ExportNamedDeclaration(path) {
        const { declaration } = path.node;
        if (declaration && declaration.type === 'FunctionDeclaration') {
          const funcName = declaration.id?.name;
          if (funcName) {
            exportedFunctions.push(funcName);
          }
        }
      },
      ExportSpecifier(path) {
        const exportedNode = path.node.exported;
        const funcName = 'name' in exportedNode ? exportedNode.name : exportedNode.value;
        exportedFunctions.push(funcName);
      },
    });

    return exportedFunctions;
  }
}


---------
/// my-low-code-app/backend/src/controllers/authController.ts

// backend/src/controllers/authController.ts

import { Request, Response } from 'express';
import User, { IUser } from '../models/User';
import Joi from 'joi';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

/**
 * Inscription d'un nouvel utilisateur
 */
export const register = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    password: Joi.string().min(6).required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Registration validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Vérifier si l'utilisateur existe déjà
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      logger.warn(`Registration failed: Username "${username}" already exists.`);
      return res.status(400).json({ message: 'Username already exists.' });
    }

    // Créer un nouvel utilisateur
    const newUser = new User({ username, password });
    await newUser.save();

    logger.info(`User "${username}" registered successfully.`);
    res.status(201).json({ message: 'User registered successfully.' });
  } catch (error: any) {
    logger.error(`Error during registration: ${error.message}`);
    res.status(500).json({ message: 'Registration failed.', error: error.message });
  }
};

/**
 * Connexion d'un utilisateur existant
 */
export const login = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().required(),
    password: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Login validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Trouver l'utilisateur
    const user = await User.findOne({ username });
    if (!user) {
      logger.warn(`Login failed: Username "${username}" not found.`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Comparer les mots de passe
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      logger.warn(`Login failed: Incorrect password for username "${username}".`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Créer un token JWT
    const token = jwt.sign({ userId: user._id }, SECRET_KEY, { expiresIn: '1h' });

    logger.info(`User "${username}" logged in successfully.`);
    res.json({ message: 'Login successful.', token });
  } catch (error: any) {
    logger.error(`Error during login: ${error.message}`);
    res.status(500).json({ message: 'Login failed.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/devServerController.ts

// backend/src/controllers/devServerController.ts

import { Request, Response } from 'express';
import { exec, ChildProcess } from 'child_process';
import path from 'path';
import fs from 'fs/promises';
import portfinder from 'portfinder';
import logger from '../utils/logger'; // Assurez-vous d'avoir configuré un logger, par exemple avec winston

let devServerProcess: ChildProcess | null = null;

/**
 * Démarre un serveur de développement pour un projet donné.
 * @param req - Requête Express contenant le nom du projet dans le corps.
 * @param res - Réponse Express.
 */
export const startDevServer = async (req: Request, res: Response) => {
  const { project } = req.body;

  if (!project) {
    logger.error('Error: Project is required to start the development server.');
    return res.status(400).json({ message: 'Project is required.' });
  }

  if (devServerProcess) {
    logger.warn('Attempted to start development server, but one is already running.');
    return res.status(400).json({ message: 'Development server is already running.' });
  }

  const projectPath = path.join(__dirname, '..', 'projects', project);

  try {
    // Vérifier si le dossier du projet existe
    await fs.access(projectPath);
    logger.info(`Starting development server for project: ${project} at path: ${projectPath}`);
  } catch (error) {
    logger.error(`Project directory does not exist: ${projectPath}`);
    return res.status(404).json({ message: 'Project directory does not exist.' });
  }

  try {
    // Trouver un port libre à partir de 4000
    const port = await portfinder.getPortPromise({ port: 4000 });

    // Commande pour démarrer le serveur de développement (par exemple, avec nodemon)
    const command = `npx nodemon index.js`; // Assurez-vous que 'index.js' est le fichier d'entrée de votre projet

    devServerProcess = exec(`PORT=${port} ${command}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Development server error: ${error.message}`);
        return;
      }
      if (stderr) {
        logger.error(`Development server stderr: ${stderr}`);
        return;
      }
      logger.info(`Development server stdout: ${stdout}`);
    });

    // Gestion de la sortie du processus
    devServerProcess.on('exit', (code, signal) => {
      logger.info(`Development server exited with code ${code} and signal ${signal}`);
      devServerProcess = null;
    });

    logger.info(`Development server started successfully on port ${port}`);
    res.json({ message: 'Development server started successfully.', port });
  } catch (error: any) {
    logger.error(`Failed to start development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to start development server.', error: error.message });
  }
};

/**
 * Arrête le serveur de développement en cours.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const stopDevServer = async (req: Request, res: Response) => {
  if (!devServerProcess) {
    logger.warn('Attempted to stop development server, but none is running.');
    return res.status(400).json({ message: 'Development server is not running.' });
  }

  try {
    devServerProcess.kill();
    logger.info('Development server stopped successfully.');
    devServerProcess = null;
    res.json({ message: 'Development server stopped successfully.' });
  } catch (error: any) {
    logger.error(`Failed to stop development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to stop development server.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/executeController.ts

import { Request, Response } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs/promises';

export const executeNode = async (req: Request, res: Response) => {
  const { project, nodeId } = req.body;

  if (!project || !nodeId) {
    console.log('Error: Missing project or nodeId');
    return res.status(400).json({ message: 'Project and nodeId are required.' });
  }

  try {
    // Find the project
    console.log(`Looking for project: ${project}`);
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      console.log('Error: Project not found');
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Find the node
    console.log(`Looking for node with ID: ${nodeId}`);
    const node = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!node) {
      console.log('Error: Node not found');
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Resolve the path to the node file
    const projectPath = path.join(__dirname, '..', 'projects', project);
    const filePath = path.join(projectPath, node.data.fileName);
    console.log(`Resolved file path: ${filePath}`);

    // Check if the file exists
    try {
      await fs.access(filePath);
    } catch (error) {
      console.log('Error: Node file does not exist');
      return res.status(404).json({ message: 'Node file does not exist.' });
    }

    // Execute the file
    const command = `node ${filePath}`;
    console.log(`Executing command: ${command}`);
    exec(command, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing node: ${error.message}`);
        return res.status(500).json({ message: 'Error executing node.', error: error.message });
      }

      console.log('Node executed successfully');
      console.log(`stdout: ${stdout}`);
      console.log(`stderr: ${stderr}`);

      res.json({
        message: 'Node executed successfully.',
        stdout: stdout.trim(),
        stderr: stderr.trim(),
      });
    });

  } catch (error: any) {
    console.error('Error during node execution:', error);
    res.status(500).json({ message: 'Error during node execution.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/fileController.ts

// backend/src/controllers/fileController.ts

import { Request, Response } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { getFilePath, writeFile, checkFileExists } from '../utils/fileUtils';
import fs from 'fs/promises';
import Joi from 'joi';
import logger from '../utils/logger';

/**
 * Met à jour un fichier de nœud spécifique dans un projet.
 * @param req - Requête Express contenant project, nodeId et nodeData dans le corps.
 * @param res - Réponse Express.
 */
export const updateFile = async (req: Request, res: Response) => {
  const { project, nodeId, nodeData } = req.body;

  // Validation des données entrantes
  const schema = Joi.object({
    project: Joi.string().required(),
    nodeId: Joi.string().required(),
    nodeData: Joi.object({
      label: Joi.string().required(),
      fileName: Joi.string().required(),
      imports: Joi.array().items(Joi.string()).required(),
      code: Joi.string().required(),
      exportedFunctions: Joi.array().items(Joi.string()).required(),
      lintErrors: Joi.array().items(Joi.any()).optional(),
    }).required(),
  });

  const { error } = schema.validate({ project, nodeId, nodeData });
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  try {
    // Trouver et mettre à jour le nœud dans la base de données
    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      logger.warn(`Node not found: project="${project}", nodeId="${nodeId}"`);
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Résoudre le chemin du fichier
    const filePath = getFilePath(project, nodeData.fileName);
    logger.info(`Resolved file path: ${filePath}`);

    // Vérifier si le fichier existe
    const fileExists = await checkFileExists(filePath);
    let currentFileContent = '';

    // Lire le contenu actuel du fichier si il existe
    if (fileExists) {
      currentFileContent = await fs.readFile(filePath, 'utf8');
      logger.info(`Current file content loaded from: ${filePath}`);
    } else {
      logger.warn(`File does not exist: ${filePath}`);
    }

    // Écrire le fichier seulement si le contenu a changé
    if (currentFileContent !== nodeData.code) {
      await writeFile(filePath, nodeData.code);
      logger.info(`File updated: ${filePath}`);
    } else {
      logger.info('No changes in file content, skipping file write.');
    }

    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error: any) {
    logger.error(`Error updating file: ${error.message}`);
    res.status(500).json({ message: 'Error updating file.', error: error.message });
  }
};

/**
 * Récupère les fonctions accessibles pour un nœud spécifique.
 * (À implémenter selon vos besoins spécifiques)
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const getAccessibleFunctions = async (req: Request, res: Response) => {
  const { project, nodeId } = req.query;

  if (!project || typeof project !== 'string' || !nodeId || typeof nodeId !== 'string') {
    logger.error('Invalid query parameters for getAccessibleFunctions.');
    return res.status(400).json({ message: 'Project and nodeId are required and must be strings.' });
  }

  try {
    // Logique pour récupérer les fonctions accessibles
    // Cela dépend de la structure de vos nœuds et de comment les fonctions sont exposées

    // Exemple hypothétique :
    const node = await NodeModel.findOne({ project, id: nodeId });
    if (!node) {
      logger.warn(`Node not found for accessible functions: project="${project}", nodeId="${nodeId}"`);
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Supposons que les fonctions exportées sont stockées dans node.data.exportedFunctions
    const accessibleFunctions = node.data.exportedFunctions;

    res.json({ accessibleFunctions });
  } catch (error: any) {
    logger.error(`Error fetching accessible functions: ${error.message}`);
    res.status(500).json({ message: 'Error fetching accessible functions.', error: error.message });
  }
};

/**
 * Met à jour un fichier de nœud spécifique. (Alternative ou extension de updateFile)
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const updateNode = async (req: Request, res: Response) => {
  console.log('Request received for updating node');
  const { project, nodeId, nodeData } = req.body;

  // Log the incoming data
  console.log('Incoming request data:', { project, nodeId, nodeData });

  if (!project || !nodeId || !nodeData) {
    console.log('Validation failed: Missing project, nodeId, or nodeData');
    return res.status(400).json({ message: 'Project, nodeId, and nodeData are required.' });
  }

  try {
    // Check that all required fields in nodeData are present
    const requiredFields = ['label', 'fileName', 'code'];
    for (const field of requiredFields) {
      if (!nodeData[field]) {
        console.log(`Validation failed: Field '${field}' is missing in nodeData`);
        return res.status(400).json({ message: `Field '${field}' is required in nodeData.` });
      }
    }

    // Try to find and update the node in the database
    console.log('Finding node in the database...');
    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      console.log('Node not found in the database.');
      return res.status(404).json({ message: 'Node not found.' });
    }

    console.log('Node successfully updated in the database:', updatedNode);

    // Now write the updated code to the file system
    const filePath = getFilePath(project, nodeData.fileName);
    console.log('Resolved file path:', filePath);

    await writeFile(filePath, nodeData.code);
    console.log(`File successfully written to path: ${filePath}`);

    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error) {
    // Catch and log any errors that occur
    console.error('Error updating node or writing file:', error);
    res.status(500).json({ message: 'Error updating node or writing file.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/gitController.ts

// backend/src/controllers/gitController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import EdgeModel from '../models/Edge';
import logger from '../utils/logger';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import simpleGit, { SimpleGit } from 'simple-git';

const git: SimpleGit = simpleGit();

/**
 * Fonction pour extraire les fonctions exportées d'un fichier.
 */
async function extractExportedFunctions(filePath: string): Promise<string[]> {
  const code = await fs.readFile(filePath, 'utf-8');
  const exportedFunctions: string[] = [];
  const ast = parse(code, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx'],
  });

  traverse(ast, {
    ExportNamedDeclaration(path) {
      const { declaration } = path.node;
      if (declaration && declaration.type === 'FunctionDeclaration') {
        const funcName = declaration.id?.name;
        if (funcName) {
          exportedFunctions.push(funcName);
        }
      }
    },
    ExportSpecifier(path) {
      const exportedNode = path.node.exported;
      const funcName = 'name' in exportedNode ? exportedNode.name : exportedNode.value;
      exportedFunctions.push(funcName);
    },
  });

  return exportedFunctions;
}

/**
 * Fonction pour analyser les fichiers et générer les nœuds et arêtes.
 */
async function analyzeProjectFiles(projectPath: string, projectId: string) {
  // Récupérer tous les fichiers .js et .ts, y compris dans les sous-dossiers
  const jsTsFiles: string[] = [];

  async function getJsTsFiles(dirPath: string) {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      if (entry.isDirectory()) {
        await getJsTsFiles(fullPath);
      } else if (entry.isFile() && (entry.name.endsWith('.js') || entry.name.endsWith('.ts'))) {
        jsTsFiles.push(fullPath);
      }
    }
  }

  await getJsTsFiles(projectPath);

  const nodes: any[] = [];
  const edges: any[] = [];

  for (const filePath of jsTsFiles) {
    const content = await fs.readFile(filePath, 'utf-8');
    const exportedFunctions = await extractExportedFunctions(filePath);

    // Extraire les imports pour créer des arêtes
    const imports: string[] = [];
    const ast = parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      ImportDeclaration(path) {
        const source = path.node.source.value;
        imports.push(source);
      },
    });

    // Créer un nœud pour ce fichier
    const relativeFilePath = path.relative(projectPath, filePath);
    const nodeId = relativeFilePath.replace(/\\/g, '/'); // Utiliser le chemin relatif comme ID
    const newNode = {
      project: projectId,
      id: nodeId,
      type: 'code',
      position: { x: Math.random() * 500, y: Math.random() * 500 }, // Position aléatoire ou basée sur une logique
      data: {
        label: path.basename(filePath),
        fileName: relativeFilePath,
        imports: imports,
        code: content,
        exportedFunctions: exportedFunctions,
      },
    };

    nodes.push(newNode);

    // Créer des arêtes basées sur les imports
    for (const imp of imports) {
      // Résoudre le chemin relatif ou les modules
      let target = imp;
      if (imp.startsWith('./') || imp.startsWith('../')) {
        const importPath = path.resolve(path.dirname(filePath), imp);
        const importFile = path.relative(projectPath, importPath).replace(/\\/g, '/');
        target = importFile;
      }

      edges.push({
        project: projectId,
        id: `edge_${nodeId}_to_${target}`,
        source: nodeId,
        target: target,
        animated: false,
        label: 'imports',
      });
    }
  }

  // Enregistrer les nœuds dans la base de données
  for (const node of nodes) {
    await NodeModel.findOneAndUpdate(
      { project: node.project, id: node.id },
      node,
      { upsert: true, new: true, runValidators: true }
    );
    logger.info(`Nœud créé/mis à jour pour le fichier: ${node.id}`);
  }

  // Enregistrer les arêtes dans la base de données
  for (const edge of edges) {
    await EdgeModel.findOneAndUpdate(
      { project: edge.project, id: edge.id },
      edge,
      { upsert: true, new: true, runValidators: true }
    );
    logger.info(`Arête créée/mise à jour: ${edge.id}`);
  }
}

/**
 * Cloner ou mettre à jour un dépôt Git et analyser le projet.
 */
export const pullFromGit = async (req: Request, res: Response) => {
  const { repoUrl } = req.body;

  if (!repoUrl) {
    logger.warn('Tentative de pull Git sans URL de dépôt');
    return res.status(400).json({ error: 'URL du dépôt Git requise' });
  }

  const projectName = path.basename(repoUrl, '.git');
  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    // Cloner ou mettre à jour le projet
    const projectExists = await fs.access(projectPath).then(() => true).catch(() => false);
    if (projectExists) {
      await git.cwd(projectPath);
      await git.pull();
      logger.info(`Git pull réussi pour le projet: ${projectName}`);
    } else {
      await git.clone(repoUrl, projectPath);
      logger.info(`Git clone réussi: ${repoUrl} dans ${projectPath}`);
    }

    // Créer ou mettre à jour le projet dans la base de données
    let project = await Project.findOne({ name: projectName });
    if (!project) {
      project = new Project({ name: projectName });
      await project.save();
      logger.info(`Nouveau projet créé dans la base de données: ${projectName}`);
    }

    // Installer les dépendances du projet
    await new Promise<void>((resolve, reject) => {
      exec('npm install', { cwd: projectPath }, (error, stdout, stderr) => {
        if (error) {
          logger.error(`Erreur lors de l'installation des dépendances: ${error.message}`);
          return reject(error);
        }
        logger.info(`npm install réussi pour le projet: ${projectName}`);
        resolve();
      });
    });

    // Analyser le projet et créer/mettre à jour les nœuds et arêtes
    await analyzeProjectFiles(projectPath, project._id.toString());

    res.json({ message: 'Projet importé et installé avec succès', projectName });
  } catch (error: any) {
    logger.error(`Erreur lors de l'importation du projet: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de l\'importation du projet', error: error.message });
  }
};

/**
 * Commiter les changements locaux avec un message de commit.
 */
export const commitChanges = async (req: Request, res: Response) => {
  const { projectName, commitMessage } = req.body;

  if (!projectName || !commitMessage) {
    return res.status(400).json({ message: 'Le nom du projet et le message de commit sont requis.' });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    await git.add('.');
    await git.commit(commitMessage);

    logger.info(`Changements commités dans le projet ${projectName} avec le message: ${commitMessage}`);
    res.json({ message: 'Changements commités avec succès.' });
  } catch (error: any) {
    logger.error(`Erreur lors du commit des changements: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors du commit des changements.', error: error.message });
  }
};

/**
 * Pousser les changements locaux vers le dépôt distant.
 */
export const pushChanges = async (req: Request, res: Response) => {
  const { projectName } = req.body;

  if (!projectName) {
    return res.status(400).json({ message: 'Le nom du projet est requis.' });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    await git.push();

    logger.info(`Changements poussés vers le dépôt distant pour le projet ${projectName}`);
    res.json({ message: 'Changements poussés avec succès.' });
  } catch (error: any) {
    logger.error(`Erreur lors du push des changements: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors du push des changements.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/graphController.ts

// backend/src/controllers/graphController.ts

import { Request, Response } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import path from 'path';
import fs from 'fs/promises';

export const getProjectGraph = async (req: Request, res: Response) => {
  const { project } = req.query;

  if (!project || typeof project !== 'string') {
    return res.status(400).json({ message: 'Project is required and must be a string.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    const nodes = await NodeModel.find({ project: existingProject._id });
    const edges = await Edge.find({ project: existingProject._id });

    res.json({ graph: { nodes, edges } });
  } catch (error) {
    console.error('Error fetching project graph:', error);
    res.status(500).json({ message: 'Error fetching project graph.' });
  }
};

export const updateGraph = async (req: Request, res: Response) => {
  const { project, nodes, edges } = req.body;

  console.log('Received updateGraph request:', req.body); // Log des données reçues

  if (!project || !nodes || !edges) {
    return res.status(400).json({ message: 'Project, nodes, and edges are required.' });
  }

  if (typeof project !== 'string' || !Array.isArray(nodes) || !Array.isArray(edges)) {
    return res.status(400).json({ message: 'Invalid data types for project, nodes, or edges.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      console.error(`Project "${project}" not found.`);
      return res.status(404).json({ message: 'Project not found.' });
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);

    // Vérifier si le dossier du projet existe
    try {
      await fs.access(projectPath);
    } catch (err) {
      console.error(`Project directory "${projectPath}" does not exist.`);
      return res.status(400).json({ message: 'Project directory does not exist.' });
    }

    // Préparer les opérations bulkWrite pour les nœuds
    const nodeOperations = nodes.map((node: any) => ({
      updateOne: {
        filter: { project: existingProject._id, id: node.id },
        update: { 
          project: existingProject._id,
          id: node.id || `node_${Date.now()}`,
          type: node.type || 'code',
          position: node.position || { x: 0, y: 0 },
          data: {
            label: node.data.label || node.data.fileName || 'Unnamed Node',
            fileName: node.data.fileName || 'UnnamedFile.js',
            imports: node.data.imports || [],
            code: node.data.code || '// No code provided',
            exportedFunctions: node.data.exportedFunctions || [],
            lintErrors: node.data.lintErrors || [],
          },
        },
        upsert: true,
      },
    }));

    // Préparer les opérations bulkWrite pour les arêtes
    const edgeOperations = edges.map((edge: any) => ({
      updateOne: {
        filter: { project: existingProject._id, id: edge.id },
        update: { 
          project: existingProject._id,
          id: edge.id || `edge_${Date.now()}`,
          source: edge.source || 'unknown_source',
          target: edge.target || 'unknown_target',
          animated: edge.animated || false,
          style: edge.style || {},
        },
        upsert: true,
      },
    }));

    console.log('Prepared node operations:', nodeOperations);
    console.log('Prepared edge operations:', edgeOperations);

    let bulkWriteResultNodes, bulkWriteResultEdges;

    if (nodeOperations.length > 0) {
      bulkWriteResultNodes = await NodeModel.bulkWrite(nodeOperations);
      console.log('Nodes upserted successfully.', bulkWriteResultNodes);
    }

    if (edgeOperations.length > 0) {
      bulkWriteResultEdges = await Edge.bulkWrite(edgeOperations);
      console.log('Edges upserted successfully.', bulkWriteResultEdges);
    }

    // Valider les arêtes pour s'assurer que les sources et targets existent
    const existingNodeIds = nodes.map((node: any) => node.id);
    const invalidEdges = edges.filter((edge: any) => 
      !existingNodeIds.includes(edge.source) || !existingNodeIds.includes(edge.target)
    );

    if (invalidEdges.length > 0) {
      console.warn('Invalid edges found:', invalidEdges);
      return res.status(400).json({ 
        message: 'One or more edges have invalid source or target node IDs.',
        invalidEdges 
      });
    }

    // Écrire les fichiers des nœuds dans le système de fichiers
    for (const node of nodes) {
      const filePath = path.join(projectPath, node.data.fileName);
      try {
        await fs.writeFile(filePath, node.data.code);
        console.log(`File written: ${filePath}`);
      } catch (fsError) {
        console.error(`Error writing file ${filePath}:`, fsError);
        return res.status(500).json({ message: `Error writing file for node ${node.id}.`, error: fsError.message });
      }
    }

    res.json({ message: 'Graph updated successfully.' });
  } catch (error) {
    console.error('Error updating graph:', error);
    res.status(500).json({ message: 'Error updating graph.', error: error.message });
  }
};

export const deleteNode = async (req: Request, res: Response) => {
  const { project, nodeId } = req.body;

  if (!project || !nodeId) {
    return res.status(400).json({ message: 'Project and nodeId are required.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Trouver le nœud à supprimer
    const nodeToDelete = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!nodeToDelete) {
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Chemin vers le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', project);
    const filePath = path.join(projectPath, nodeToDelete.data.fileName);

    // Supprimer le fichier du nœud
    try {
      await fs.unlink(filePath);
      console.log(`File deleted: ${filePath}`);
    } catch (error) {
      console.warn(`File not found for deletion: ${filePath}`);
    }

    // Supprimer le nœud
    await NodeModel.deleteOne({ project: existingProject._id, id: nodeId });

    // Supprimer les arêtes associées
    await Edge.deleteMany({ project: existingProject._id, $or: [{ source: nodeId }, { target: nodeId }] });

    res.json({ message: 'Node and associated edges deleted successfully.' });
  } catch (error) {
    console.error('Error deleting node:', error);
    res.status(500).json({ message: 'Error deleting node.' });
  }
};

export const cloneNode = async (req: Request, res: Response) => {
  const { project, nodeId, newNodeId } = req.body;

  if (!project || !nodeId || !newNodeId) {
    return res.status(400).json({ message: 'Project, nodeId, and newNodeId are required.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    const nodeToClone = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!nodeToClone) {
      return res.status(404).json({ message: 'Node to clone not found.' });
    }

    const clonedNode = nodeToClone.toObject();
    clonedNode.id = newNodeId;
    clonedNode.position = {
      x: clonedNode.position.x + 100,
      y: clonedNode.position.y + 100,
    };
    clonedNode.data = {
      ...clonedNode.data,
      label: `${clonedNode.data.label} (Clone)`,
      fileName: `${clonedNode.data.fileName.split('.').slice(0, -1).join('.')}_clone.${clonedNode.data.fileName.split('.').pop()}`,
    };
    delete clonedNode._id;

    // Chemin vers le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', project);
    const newFilePath = path.join(projectPath, clonedNode.data.fileName);

    // Créer et écrire le fichier cloné
    await fs.writeFile(newFilePath, clonedNode.data.code);
    console.log(`Cloned file created: ${newFilePath}`);

    const newNode = new NodeModel(clonedNode);
    await newNode.save();

    res.json({ message: 'Node cloned successfully.', clonedNode: newNode });
  } catch (error) {
    console.error('Error cloning node:', error);
    res.status(500).json({ message: 'Error cloning node.' });
  }
};


---------
/// my-low-code-app/backend/src/controllers/importController.ts

import { Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import logger from '../utils/logger';

/**
 * Configuration de Multer pour stocker les fichiers uploadés dans un dossier temporaire
 */
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

/**
 * Type pour les données du fichier de projet importé
 */
interface ImportedProject {
  projectName: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      fileName: string;
      imports: string[];
      code: string;
      exportedFunctions: string[];
      lintErrors?: any[];
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    animated?: boolean;
    label?: string;
  }>;
}

/**
 * Importe un projet depuis un fichier JSON
 * @param req - Requête Express avec le fichier uploadé
 * @param res - Réponse Express
 */
export const importProject = [
  upload.single('projectFile'),
  async (req: Request, res: Response) => {
    // Validation des données
    if (!req.file) {
      logger.error('No file uploaded for project import.');
      return res.status(400).json({ message: 'Aucun fichier uploadé.' });
    }

    try {
      const projectData: ImportedProject = JSON.parse(req.file.buffer.toString('utf-8'));

      // Valider la structure du fichier
      const schema = Joi.object({
        projectName: Joi.string().alphanum().min(3).max(30).required(),
        nodes: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            type: Joi.string().required(),
            position: Joi.object({
              x: Joi.number().required(),
              y: Joi.number().required(),
            }).required(),
            data: Joi.object({
              label: Joi.string().required(),
              fileName: Joi.string().required(),
              imports: Joi.array().items(Joi.string()).required(),
              code: Joi.string().required(),
              exportedFunctions: Joi.array().items(Joi.string()).required(),
              lintErrors: Joi.array().items(Joi.any()).optional(),
            }).required(),
          })
        ).required(),
        edges: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            source: Joi.string().required(),
            target: Joi.string().required(),
            animated: Joi.boolean().optional(),
            label: Joi.string().optional(),
          })
        ).required(),
      });

      const { error } = schema.validate(projectData);
      if (error) {
        logger.error(`Validation error during project import: ${error.details[0].message}`);
        return res.status(400).json({ message: error.details[0].message });
      }

      const { projectName, nodes, edges } = projectData;

      // Vérifier si le projet existe déjà
      const existingProject = await Project.findOne({ name: projectName });
      if (existingProject) {
        logger.warn(`Import project failed: Project "${projectName}" already exists.`);
        return res.status(400).json({ message: 'Le projet existe déjà.' });
      }

      // Créer le dossier du projet
      const projectPath = path.join(__dirname, '..', 'projects', projectName);
      await fs.mkdir(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);

      // Créer les fichiers des nœuds
      for (const node of nodes) {
        const filePath = path.join(projectPath, node.data.fileName);
        await fs.writeFile(filePath, node.data.code);
        logger.info(`File created for node "${node.id}" at: ${filePath}`);
      }

      // Initialiser un package.json
      await fs.writeFile(path.join(projectPath, 'package.json'), JSON.stringify({
        name: projectName,
        version: "1.0.0",
        main: "index.js",
        scripts: {
          start: "node index.js"
        },
        dependencies: {}
      }, null, 2));
      logger.info(`package.json created at: ${path.join(projectPath, 'package.json')}`);

      // Enregistrer le projet dans la base de données
      const newProject = new Project({
        name: projectName,
      });

      const savedProject = await newProject.save();
      logger.info(`Project "${projectName}" saved to database.`);

      // Enregistrer les nœuds dans la base de données
      for (const node of nodes) {
        const newNode = new NodeModel({
          project: savedProject._id,
          id: node.id,
          type: node.type,
          position: node.position,
          data: node.data,
        });
        await newNode.save();
        logger.info(`Node "${node.id}" saved to database.`);
      }

      // Vous pouvez également enregistrer les arêtes si vous avez un modèle pour les arêtes

      res.status(201).json({ message: 'Projet importé avec succès.', project: savedProject });
    } catch (error: any) {
      logger.error(`Error during project import: ${error.message}`);
      res.status(500).json({ message: 'Erreur lors de l\'importation du projet.', error: error.message });
    }
  }
];


---------
/// my-low-code-app/backend/src/controllers/nodeController.ts

import { Request, Response } from 'express';
import { getFilePath, writeFile } from '../utils/fileUtils';
import NodeModel from '../models/Node';

export const updateNode = async (req: Request, res: Response) => {
  console.log('Request received for updating node');
  const { project, nodeId, nodeData } = req.body;

  // Log the incoming data
  console.log('Incoming request data:', { project, nodeId, nodeData });

  if (!project || !nodeId || !nodeData) {
    console.log('Validation failed: Missing project, nodeId, or nodeData');
    return res.status(400).json({ message: 'Project, nodeId, and nodeData are required.' });
  }

  try {
    // Check that all required fields in nodeData are present
    const requiredFields = ['label', 'fileName', 'code'];
    for (const field of requiredFields) {
      if (!nodeData[field]) {
        console.log(`Validation failed: Field '${field}' is missing in nodeData`);
        return res.status(400).json({ message: `Field '${field}' is required in nodeData.` });
      }
    }

    // Try to find and update the node in the database
    console.log('Finding node in the database...');
    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      console.log('Node not found in the database.');
      return res.status(404).json({ message: 'Node not found.' });
    }

    console.log('Node successfully updated in the database:', updatedNode);

    // Now write the updated code to the file system
    const filePath = getFilePath(project, nodeData.fileName);
    console.log('Resolved file path:', filePath);

    await writeFile(filePath, nodeData.code);
    console.log(`File successfully written to path: ${filePath}`);

    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error) {
    // Catch and log any errors that occur
    console.error('Error updating node or writing file:', error);
    res.status(500).json({ message: 'Error updating node or writing file.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/projectController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import simpleGit, { SimpleGit } from 'simple-git';
import logger from '../utils/logger';



// Initialiser simple-git avec l'option de journalisation
const git: SimpleGit = simpleGit();

/**
 * Crée un nouveau projet.
 * @param req - Requête Express contenant projectCode, projectName et gitRepo dans le corps.
 * @param res - Réponse Express.
 */
export const createProject = async (req: Request, res: Response) => {
  const schema = Joi.object({
    projectCode: Joi.string().required(),
    projectName: Joi.string().alphanum().min(3).max(30).required(),
    gitRepo: Joi.string().uri().optional(), // Ajouter un champ pour l'URL du dépôt Git
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { projectCode, projectName, gitRepo } = req.body;

  try {
    // Vérifier si le projet existe déjà
    const existingProject = await Project.findOne({ name: projectName });
    if (existingProject) {
      logger.warn(`Project creation failed: Project "${projectName}" already exists.`);
      return res.status(400).json({ message: 'Le projet existe déjà.' });
    }

    // Créer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);
    }

    // Initialiser Git si un dépôt Git est fourni
    if (gitRepo) {
      try {
        await git.clone(gitRepo, projectPath);
        logger.info(`Git repository cloned from ${gitRepo} into ${projectPath}`);
      } catch (gitError: any) {
        logger.error(`Failed to clone Git repository: ${gitError.message}`);
        return res.status(500).json({ message: 'Erreur lors du clonage du dépôt Git.', error: gitError.message });
      }
    }

    // Créer le fichier principal (par exemple, index.ts)
    const mainFilePath = path.join(projectPath, 'index.ts');
    fs.writeFileSync(mainFilePath, projectCode);
    logger.info(`Main file created at: ${mainFilePath}`);

    // Initialiser un package.json
    exec('npm init -y', { cwd: projectPath }, async (err, stdout, stderr) => {
      if (err) {
        logger.error(`Error initializing npm: ${err.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'initialisation du projet.' });
      }

      logger.info(`npm initialized for project "${projectName}".`);

      try {
        // Enregistrer le projet dans la base de données
        const newProject = new Project({
          name: projectName,
        });

        const savedProject = await newProject.save();
        logger.info(`Project "${projectName}" saved to database.`);

        res.status(201).json({ message: 'Projet créé avec succès.', project: savedProject });
      } catch (saveError: any) {
        logger.error(`Error saving project to database: ${saveError.message}`);
        res.status(500).json({ message: 'Erreur lors de la création du projet.', error: saveError.message });
      }
    });

  } catch (error: any) {
    logger.error(`Error creating project: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la création du projet.', error: error.message });
  }
};

/**
 * Récupère la liste des projets.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const getProjects = async (req: Request, res: Response) => {
  try {
    const projects = await Project.find().select('name createdAt');
    logger.info('Fetched list of projects.');
    res.json(projects);
  } catch (error: any) {
    logger.error(`Error fetching projects: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la récupération des projets.', error: error.message });
  }
};

/**
 * Installe un package npm dans un projet spécifique.
 * @param req - Requête Express contenant project et packageName dans le corps.
 * @param res - Réponse Express.
 */
export const installPackage = async (req: Request, res: Response) => {
  const schema = Joi.object({
    project: Joi.string().required(),
    packageName: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { project, packageName } = req.body;

  try {
    // Trouver le projet dans la base de données
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      logger.warn(`Install package failed: Project "${project}" not found.`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);

    // Vérifier si le dossier du projet existe
    if (!fs.existsSync(projectPath)) {
      logger.error(`Project directory does not exist: ${projectPath}`);
      return res.status(400).json({ message: 'Le dossier du projet n\'existe pas.' });
    }

    logger.info(`Installing package "${packageName}" in project "${project}".`);

    // Exécuter la commande npm install
    exec(`npm install ${packageName}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Error installing package: ${error.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'installation du package.', stderr: stderr });
      }

      if (stderr) {
        logger.warn(`npm stderr: ${stderr}`);
        // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
      }

      logger.info(`npm stdout: ${stdout}`);
      res.json({ message: `Package "${packageName}" installé avec succès.`, stdout, stderr });
    });
  } catch (error: any) {
    logger.error(`Error installing package: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de l\'installation du package.', error: error.message });
  }
};

export const deleteProject = async (req: Request, res: Response) => {
  const { projectName } = req.params;
  logger.info(`Attempting to delete project: ${projectName}`);

  try {
    // Supprimer le projet de la base de données
    const project = await Project.findOneAndDelete({ name: projectName });
    if (!project) {
      logger.warn(`Project not found: ${projectName}`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    logger.info(`Project "${projectName}" deleted from database.`);

    // Supprimer tous les nœuds et arêtes associés
    await NodeModel.deleteMany({ project: project._id });
    await Edge.deleteMany({ project: project._id });
    logger.info(`Associated nodes and edges deleted for project "${projectName}".`);

    // Supprimer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    logger.info(`Project path to delete: ${projectPath}`);

    await fs.promises.rm(projectPath, { recursive: true, force: true });
    logger.info(`Project directory "${projectPath}" deleted successfully.`);

    res.json({ message: 'Projet supprimé avec succès.' });
  } catch (error: any) {
    logger.error(`Error deleting project "${projectName}": ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la suppression du projet.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/middleware/auth.ts

// backend/src/middleware/auth.ts

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

interface JwtPayload {
  userId: string;
  // Ajoutez d'autres propriétés si nécessaire
}

// Extension de l'interface Request pour inclure user
declare module 'express-serve-static-core' {
  interface Request {
    user?: JwtPayload;
  }
}

export const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (authHeader) {
    // Le format attendu est "Bearer <token>"
    const token = authHeader.split(' ')[1];

    jwt.verify(token, SECRET_KEY, (err, payload) => {
      if (err) {
        logger.warn('Invalid JWT token');
        return res.sendStatus(403); // Forbidden
      }

      // Vous pouvez ajouter le payload à la requête pour une utilisation future
      req.user = payload as JwtPayload;
      next();
    });
  } else {
    logger.warn('No Authorization header provided');
    res.sendStatus(401); // Unauthorized
  }
};


---------
/// my-low-code-app/backend/src/middleware/errorHandler.ts

import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  logger.error(`Unhandled Error: ${err.message}`);
  res.status(500).json({ message: 'Internal Server Error', error: err.message });
};


---------
/// my-low-code-app/backend/src/models/Edge.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IEdge extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  source: string;
  target: string;
  animated?: boolean;
  label?: string;
  style?: Record<string, any>;
}

const EdgeSchema: Schema = new Schema({
  project: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
  id: { type: String, required: true },
  source: { type: String, required: true },
  target: { type: String, required: true },
  animated: { type: Boolean, default: false },
  label: { type: String },
  style: { type: Schema.Types.Mixed },
});

// Index composé pour assurer l'unicité de l'ID par projet
EdgeSchema.index({ project: 1, id: 1 }, { unique: true });

export default mongoose.model<IEdge>('Edge', EdgeSchema);


---------
/// my-low-code-app/backend/src/models/Node.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface INodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
  lintErrors?: any[];
}

export interface INode extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  type: string;
  position: {
    x: number;
    y: number;
  };
  data: INodeData;
}

const NodeSchema: Schema = new Schema({
  project: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
  id: { type: String, required: true },
  type: { type: String, required: true },
  position: {
    x: { type: Number, required: true, default: 0 },
    y: { type: Number, required: true, default: 0 },
  },
  data: {
    label: { type: String, required: true, default: 'Unnamed Node' },
    fileName: { type: String, required: true, default: 'UnnamedFile.js' },
    imports: { type: [String], default: [] },
    code: { type: String, required: true, default: '// No code provided' },
    exportedFunctions: { type: [String], default: [] },
    lintErrors: { type: [Schema.Types.Mixed], default: [] },
  },
});

export default mongoose.model<INode>('Node', NodeSchema);


---------
/// my-low-code-app/backend/src/models/Project.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IProject extends Document {
  name: string;
  createdAt: Date;
}

const ProjectSchema: Schema = new Schema({
  name: { type: String, required: true, unique: true },
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.model<IProject>('Project', ProjectSchema);


---------
/// my-low-code-app/backend/src/models/User.ts

import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends Document {
  username: string;
  password: string;
  comparePassword: (candidatePassword: string) => Promise<boolean>;
}

const UserSchema: Schema = new Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

// Middleware pour hacher le mot de passe avant de sauvegarder
UserSchema.pre<IUser>('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(this.password, salt);
    this.password = hashed;
    next();
  } catch (err) {
    next(err as any);
  }
});

// Méthode pour comparer les mots de passe
UserSchema.methods.comparePassword = function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);


---------
/// my-low-code-app/backend/src/routes/authRoutes.ts

// backend/src/routes/authRoutes.ts

import express from 'express';
import { register, login } from '../controllers/authController';

const router = express.Router();

/**
 * @route POST /auth/register
 * @desc Inscription d'un nouvel utilisateur
 * @access Public
 */
router.post('/register', register);

/**
 * @route POST /auth/login
 * @desc Connexion d'un utilisateur existant
 * @access Public
 */
router.post('/login', login);

export default router;


---------
/// my-low-code-app/backend/src/routes/devServerRoutes.ts

// backend/src/routes/devServerRoutes.ts

import express from 'express';
import { startDevServer, stopDevServer } from '../controllers/devServerController';

const router = express.Router();

/**
 * @route POST /dev-server/start
 * @desc Démarre le serveur de développement pour un projet donné.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/start', startDevServer);

/**
 * @route POST /dev-server/stop
 * @desc Arrête le serveur de développement en cours.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/stop', stopDevServer);

export default router;


---------
/// my-low-code-app/backend/src/routes/executeRoutes.ts

import express from 'express';
import { executeNode } from '../controllers/executeController';

const router = express.Router();

router.post('/', executeNode);

export default router;


---------
/// my-low-code-app/backend/src/routes/fileRoutes.ts

import express from 'express';
import { updateFile, getAccessibleFunctions } from '../controllers/fileController';

const router = express.Router();

router.post('/', updateFile);
router.get('/accessible-functions', getAccessibleFunctions);

export default router;

---------
/// my-low-code-app/backend/src/routes/gitRoutes.ts

import express from 'express';
import { pullFromGit, commitChanges, pushChanges } from '../controllers/gitController';

const router = express.Router();

router.post('/pull', pullFromGit);
router.post('/commit', commitChanges);
router.post('/push', pushChanges);

export default router;

---------
/// my-low-code-app/backend/src/routes/graphRoutes.ts

// backend/routes/graphRoutes.ts

import express from 'express';
import { getProjectGraph, updateGraph, deleteNode, cloneNode } from '../controllers/graphController';

const router = express.Router();

router.get('/', getProjectGraph);
router.post('/update-graph', updateGraph);
router.post('/delete-node', deleteNode);
router.post('/clone-node', cloneNode);

export default router;

---------
/// my-low-code-app/backend/src/routes/importRoutes.ts

import express from 'express';
import { importProject } from '../controllers/importController';
import { authenticateJWT } from '../middleware/auth'; // Si vous avez mis en place l'authentification

const router = express.Router();

/**
 * @route POST /import
 * @desc Importe un projet depuis un fichier JSON
 * @access Protected
 */
router.post('/import', authenticateJWT, importProject);

export default router;


---------
/// my-low-code-app/backend/src/routes/projectRoutes.ts

import express from 'express';
import { getProjects, createProject, installPackage, deleteProject } from '../controllers/projectController';

const router = express.Router();

router.get('/', getProjects);
router.post('/create-project', createProject);
router.post('/install-package', installPackage);
router.delete('/:projectName', deleteProject);

export default router;


---------
/// my-low-code-app/backend/src/server.ts

// backend/src/server.ts

import express from 'express';
import cors from 'cors';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import projectRoutes from './routes/projectRoutes';
import graphRoutes from './routes/graphRoutes';
import fileRoutes from './routes/fileRoutes';
import executeRoutes from './routes/executeRoutes';
import devServerRoutes from './routes/devServerRoutes';
import gitRoutes from './routes/gitRoutes';
import importRoutes from './routes/importRoutes';
import authRoutes from './routes/authRoutes';

import { errorHandler } from './middleware/errorHandler';
import logger from './utils/logger';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/auth', authRoutes);
app.use('/projects', projectRoutes);
app.use('/project-graph', graphRoutes);
app.use('/update-file', fileRoutes);
app.use('/execute', executeRoutes);
app.use('/dev-server', devServerRoutes);
app.use('/git', gitRoutes);
app.use('/import', importRoutes);

// Middleware de gestion des erreurs
app.use(errorHandler);

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/low-code-app')
  .then(() => {
    logger.info('Connected to MongoDB');
    app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => {
    logger.error(`MongoDB connection error: ${err.message}`);
  });

export default app;

---------
/// my-low-code-app/backend/src/types.ts

// backend/src/types.ts

export interface NodePosition {
  x: number;
  y: number;
}

export interface NodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
}

export interface Node {
  id: string;
  type: string;
  position: NodePosition;
  data: NodeData;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  label?: string;
}

export interface ProjectGraph {
  nodes: Node[];
  edges: Edge[];
}

---------
/// my-low-code-app/backend/src/utils/compileNodes.ts

import { INode } from '../models/Node';

export function compileNodes(nodes: INode[], entryFile: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Ajouter les imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Ajouter le code du node dans une closure
    compiledCode += `
(function(module, exports) {
  ${node.data.code}
})((module = { exports: {} }, exports = module.exports));
`;
    // Exporter les fonctions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `module.exports.${func} = ${func};\n`;
    });
  }

  // Commencer la compilation à partir du fichier d'entrée
  compileNode(entryFile);

  return compiledCode;
}


---------
/// my-low-code-app/backend/src/utils/executeCode.ts

import { exec } from 'child_process';
import path from 'path';

export const executeCode = (filePath: string, callback: (error: Error | null, result: { stdout: string; stderr: string } | null) => void) => {
  exec(`node ${filePath}`, (error, stdout, stderr) => {
    if (error) {
      console.error(`Execution error: ${error.message}`);
      return callback(error, null);
    }

    if (stderr) {
      console.error(`stderr: ${stderr}`);
      // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
    }

    console.log(`stdout: ${stdout}`);
    callback(null, { stdout, stderr });
  });
};


---------
/// my-low-code-app/backend/src/utils/fileUtils.ts

// backend/src/utils/fileUtils.ts

import fs from 'fs/promises';
import path from 'path';
import logger from './logger';

/**
 * Vérifie si un fichier existe.
 * @param filePath - Chemin du fichier à vérifier.
 * @returns Promise<boolean> indiquant si le fichier existe.
 */
export async function checkFileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Écrit du contenu dans un fichier.
 * @param filePath - Chemin du fichier à écrire.
 * @param content - Contenu à écrire dans le fichier.
 */
export async function writeFile(filePath: string, content: string): Promise<void> {
  logger.info(`Attempting to write file: ${filePath}`);
  try {
    await fs.writeFile(filePath, content);
    logger.info(`File successfully written at ${filePath}`);
  } catch (error) {
    logger.error(`Error writing file at ${filePath}: ${(error as Error).message}`);
    throw error; // Propager l'erreur
  }
}

/**
 * Résout le chemin du fichier pour un projet donné.
 * @param project - Nom du projet.
 * @param fileName - Nom du fichier.
 * @returns Chemin complet du fichier.
 */
export function getFilePath(project: string, fileName: string): string {
  const projectPath = path.join(__dirname, '..', 'projects', project);
  logger.info(`Building file path for project: ${project}, File name: ${fileName}`);
  return path.join(projectPath, fileName);
}


---------
/// my-low-code-app/backend/src/utils/logger.ts

import { createLogger, format, transports } from 'winston';

const logger = createLogger({
  level: 'info', // Niveau de log (error, warn, info, verbose, debug, silly)
  format: format.combine(
    format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    format.printf(info => `${info.timestamp} [${info.level.toUpperCase()}]: ${info.message}`)
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' }),
  ],
});

export default logger;


---------
/// my-low-code-app/backend/src/utils.ts

import { Node, Edge } from './types';

/**
 * Function to sanitize variable names.
 * Replace all invalid characters with underscores.
 * @param name Variable name to sanitize.
 * @returns Sanitized variable name.
 */
function sanitizeVariableName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

export function compileNodes(nodes: Node[], entryNodeId: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.error(`Node with id ${nodeId} not found`);
      return;
    }

    // Add imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Add node code within a closure
    const sanitizedFileName = sanitizeVariableName(node.data.fileName);
    compiledCode += `
const ${sanitizedFileName} = (function() {
  const module = { exports: {} };
  const exports = module.exports;
  ${node.data.code}
  return module.exports;
})();
`;

    // Export functions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `if (typeof ${sanitizedFileName}.${func} === 'function') {
  globalThis.${func} = ${sanitizedFileName}.${func};
}\n`;
    });
  }

  // Start compilation from the entry node
  compileNode(entryNodeId);

  return compiledCode;
}


 my-low-code-app/frontend/src/App.tsx

// frontend/src/App.tsx

import React from 'react';
import { Box } from '@chakra-ui/react';
import { ReactFlowProvider } from 'reactflow';
import { Sidebar } from './components/Sidebar';
import { GraphCanvas } from './components/GraphCanvas';
import { Console } from './components/Console';
import { Modals } from './components/Modals';
import { ProjectStructure } from './components/ProjectStructure';
import { AlertProvider } from './contexts/AlertContext';
import { ProjectProvider } from './contexts/ProjectContext';
import { GraphProvider } from './contexts/GraphContext';
import ErrorBoundary from './components/ErrorBoundary';
import { ModalProvider } from './contexts/ModalContext';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <AlertProvider>
        <ProjectProvider>
          <GraphProvider>
            <ModalProvider>
              <ReactFlowProvider>
                <Box display="flex" height="100vh">
                  <Sidebar />
                  <GraphCanvas />
                  <Box display="flex" flexDirection="column" width="40%">
                    <ProjectStructure />
                    <Console />
                  </Box>
                  <Modals />
                </Box>
              </ReactFlowProvider>
            </ModalProvider>
          </GraphProvider>
        </ProjectProvider>
      </AlertProvider>
    </ErrorBoundary>
  );
};

export default App;

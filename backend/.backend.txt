/// my-low-code-app/backend/src/context.ts

// backend/src/context.ts

import { parse } from '@babel/parser';
import traverse from '@babel/traverse';

export class Context {
  [key: string]: any;

  constructor(exportedFunctions: { [key: string]: Function }) {
    for (const funcName in exportedFunctions) {
      if (exportedFunctions.hasOwnProperty(funcName)) {
        this[funcName] = exportedFunctions[funcName];
      }
    }
  }

  static extractExportedFunctions(code: string): string[] {
    const exportedFunctions: string[] = [];
    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      ExportNamedDeclaration(path) {
        const { declaration } = path.node;
        if (declaration && declaration.type === 'FunctionDeclaration') {
          const funcName = declaration.id?.name;
          if (funcName) {
            exportedFunctions.push(funcName);
          }
        }
      },
      ExportSpecifier(path) {
        const exportedNode = path.node.exported;
        const funcName = 'name' in exportedNode ? exportedNode.name : exportedNode.value;
        exportedFunctions.push(funcName);
      },
    });

    return exportedFunctions;
  }
}


---------
/// my-low-code-app/backend/src/controllers/authController.ts

// backend/src/controllers/authController.ts

import { Request, Response } from 'express';
import User, { IUser } from '../models/User';
import Joi from 'joi';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

/**
 * Inscription d'un nouvel utilisateur
 */
export const register = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    password: Joi.string().min(6).required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Registration validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Vérifier si l'utilisateur existe déjà
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      logger.warn(`Registration failed: Username "${username}" already exists.`);
      return res.status(400).json({ message: 'Username already exists.' });
    }

    // Créer un nouvel utilisateur
    const newUser = new User({ username, password });
    await newUser.save();

    logger.info(`User "${username}" registered successfully.`);
    res.status(201).json({ message: 'User registered successfully.' });
  } catch (error: any) {
    logger.error(`Error during registration: ${error.message}`);
    res.status(500).json({ message: 'Registration failed.', error: error.message });
  }
};

/**
 * Connexion d'un utilisateur existant
 */
export const login = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().required(),
    password: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Login validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Trouver l'utilisateur
    const user = await User.findOne({ username });
    if (!user) {
      logger.warn(`Login failed: Username "${username}" not found.`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Comparer les mots de passe
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      logger.warn(`Login failed: Incorrect password for username "${username}".`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Créer un token JWT
    const token = jwt.sign({ userId: user._id }, SECRET_KEY, { expiresIn: '1h' });

    logger.info(`User "${username}" logged in successfully.`);
    res.json({ message: 'Login successful.', token });
  } catch (error: any) {
    logger.error(`Error during login: ${error.message}`);
    res.status(500).json({ message: 'Login failed.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/devServerController.ts

// backend/src/controllers/devServerController.ts

import { Request, Response } from 'express';
import { exec, ChildProcess } from 'child_process';
import path from 'path';
import fs from 'fs/promises';
import portfinder from 'portfinder';
import logger from '../utils/logger'; // Assurez-vous d'avoir configuré un logger, par exemple avec winston

let devServerProcess: ChildProcess | null = null;

/**
 * Démarre un serveur de développement pour un projet donné.
 * @param req - Requête Express contenant le nom du projet dans le corps.
 * @param res - Réponse Express.
 */
export const startDevServer = async (req: Request, res: Response) => {
  const { project } = req.body;

  if (!project) {
    logger.error('Error: Project is required to start the development server.');
    return res.status(400).json({ message: 'Project is required.' });
  }

  if (devServerProcess) {
    logger.warn('Attempted to start development server, but one is already running.');
    return res.status(400).json({ message: 'Development server is already running.' });
  }

  const projectPath = path.join(__dirname, '..', 'projects', project);

  try {
    // Vérifier si le dossier du projet existe
    await fs.access(projectPath);
    logger.info(`Starting development server for project: ${project} at path: ${projectPath}`);
  } catch (error) {
    logger.error(`Project directory does not exist: ${projectPath}`);
    return res.status(404).json({ message: 'Project directory does not exist.' });
  }

  try {
    // Trouver un port libre à partir de 4000
    const port = await portfinder.getPortPromise({ port: 4000 });

    // Commande pour démarrer le serveur de développement (par exemple, avec nodemon)
    const command = `npx nodemon index.js`; // Assurez-vous que 'index.js' est le fichier d'entrée de votre projet

    devServerProcess = exec(`PORT=${port} ${command}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Development server error: ${error.message}`);
        return;
      }
      if (stderr) {
        logger.error(`Development server stderr: ${stderr}`);
        return;
      }
      logger.info(`Development server stdout: ${stdout}`);
    });

    // Gestion de la sortie du processus
    devServerProcess.on('exit', (code, signal) => {
      logger.info(`Development server exited with code ${code} and signal ${signal}`);
      devServerProcess = null;
    });

    logger.info(`Development server started successfully on port ${port}`);
    res.json({ message: 'Development server started successfully.', port });
  } catch (error: any) {
    logger.error(`Failed to start development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to start development server.', error: error.message });
  }
};

/**
 * Arrête le serveur de développement en cours.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const stopDevServer = async (req: Request, res: Response) => {
  if (!devServerProcess) {
    logger.warn('Attempted to stop development server, but none is running.');
    return res.status(400).json({ message: 'Development server is not running.' });
  }

  try {
    devServerProcess.kill();
    logger.info('Development server stopped successfully.');
    devServerProcess = null;
    res.json({ message: 'Development server stopped successfully.' });
  } catch (error: any) {
    logger.error(`Failed to stop development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to stop development server.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/executeController.ts

import { Request, Response } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs/promises';

export const executeNode = async (req: Request, res: Response) => {
  const { project, nodeId } = req.body;

  if (!project || !nodeId) {
    console.log('Error: Missing project or nodeId');
    return res.status(400).json({ message: 'Project and nodeId are required.' });
  }

  try {
    // Find the project
    console.log(`Looking for project: ${project}`);
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      console.log('Error: Project not found');
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Find the node
    console.log(`Looking for node with ID: ${nodeId}`);
    const node = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!node) {
      console.log('Error: Node not found');
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Resolve the path to the node file
    const projectPath = path.join(__dirname, '..', 'projects', project);
    const filePath = path.join(projectPath, node.data.fileName);
    console.log(`Resolved file path: ${filePath}`);

    // Check if the file exists
    try {
      await fs.access(filePath);
    } catch (error) {
      console.log('Error: Node file does not exist');
      return res.status(404).json({ message: 'Node file does not exist.' });
    }

    // Execute the file
    const command = `node ${filePath}`;
    console.log(`Executing command: ${command}`);
    exec(command, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing node: ${error.message}`);
        return res.status(500).json({ message: 'Error executing node.', error: error.message });
      }

      console.log('Node executed successfully');
      console.log(`stdout: ${stdout}`);
      console.log(`stderr: ${stderr}`);

      res.json({
        message: 'Node executed successfully.',
        stdout: stdout.trim(),
        stderr: stderr.trim(),
      });
    });

  } catch (error: any) {
    console.error('Error during node execution:', error);
    res.status(500).json({ message: 'Error during node execution.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/controllers/fileController.ts

// backend/src/controllers/fileController.ts

import { Request, Response, NextFunction } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { getFilePath, writeFile } from '../utils/fileUtils';
import fs from 'fs/promises';
import Joi from 'joi';
import logger from '../utils/logger';
import path from 'path';
import rateLimit from 'express-rate-limit';
import compression from 'compression';
import NodeCache from 'node-cache';

// Configuration du cache
const fileCache = new NodeCache({ stdTTL: 300 }); // 5 minutes TTL

// Enum pour les codes d'erreur
enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NODE_NOT_FOUND = 'NODE_NOT_FOUND',
  FILE_WRITE_ERROR = 'FILE_WRITE_ERROR',
  FILE_READ_ERROR = 'FILE_READ_ERROR',
  PROJECT_NOT_FOUND = 'PROJECT_NOT_FOUND',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

// Configuration du rate limiter
export const updateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limite chaque IP à 100 requêtes par fenêtre
  message: 'Too many update requests from this IP'
});

// Configuration de la compression
export const compressionMiddleware = compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  },
  threshold: 1024 // Compresse seulement les réponses plus grandes que 1KB
});

// Middleware de performance
export const performanceMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = process.hrtime();
  res.on('finish', () => {
    const [seconds, nanoseconds] = process.hrtime(start);
    const duration = seconds * 1000 + nanoseconds / 1e6;
    logger.info(`${req.method} ${req.url} - ${duration.toFixed(2)}ms`);
  });
  next();
};

// Schémas de validation
const NODE_DATA_SCHEMA = Joi.object({
  project: Joi.string().required(),
  nodeId: Joi.string().required(),
  nodeData: Joi.object({
    label: Joi.string().required(),
    fileName: Joi.string().required(),
    imports: Joi.array().items(Joi.string()).required(),
    code: Joi.string().required(),
    exportedFunctions: Joi.array().items(Joi.string()).required(),
    lintErrors: Joi.array().items(Joi.any()).optional(),
  }).required(),
}).cache();

// Gestionnaire d'erreurs central
const handleError = (error: any, res: Response) => {
  const errorCode = error.code || ErrorCode.UNKNOWN_ERROR;
  logger.error(`${errorCode}: ${error.message}`);
  const status = error.status || 500;
  res.status(status).json({
    code: errorCode,
    message: error.message,
    details: error.details || null
  });
};

// Fonctions utilitaires
const validateFilePath = (filePath: string): boolean => {
  const normalizedPath = path.normalize(filePath);
  const projectRoot = path.normalize(path.join(__dirname, '..', 'projects'));
  return normalizedPath.startsWith(projectRoot) && !normalizedPath.includes('..');
};

const validateProject = async (project: string): Promise<boolean> => {
  try {
    const projectExists = await Project.exists({ name: project });
    if (!projectExists) return false;
    
    const projectPath = path.join(__dirname, '..', 'projects', project);
    await fs.access(projectPath);
    
    return true;
  } catch (error) {
    logger.error(`Project validation error: ${error}`);
    return false;
  }
};

const checkFileChanges = async (filePath: string, newContent: string): Promise<boolean> => {
  try {
    const fileExists = await fs.access(filePath)
      .then(() => true)
      .catch(() => false);
    
    if (!fileExists) return true;

    const currentContent = await fs.readFile(filePath, 'utf8');
    return currentContent !== newContent;
  } catch (error) {
    logger.error(`Error checking file changes: ${error}`);
    return true;
  }
};

const getCachedFile = async (filePath: string): Promise<string | null> => {
  const cached = fileCache.get<string>(filePath);
  if (cached) return cached;
  
  try {
    const content = await fs.readFile(filePath, 'utf8');
    fileCache.set(filePath, content);
    return content;
  } catch (error) {
    logger.error(`Cache miss error: ${error}`);
    return null;
  }
};

/**
 * Met à jour un fichier de nœud spécifique dans un projet.
 */
export const updateFile = async (req: Request, res: Response) => {
  const { project, nodeId, nodeData } = req.body;

  try {
    // Validation des données entrantes
    const { error } = NODE_DATA_SCHEMA.validate({ project, nodeId, nodeData });
    if (error) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: error.details[0].message 
      };
    }

    // Validation du projet
    const isValidProject = await validateProject(project);
    if (!isValidProject) {
      throw { 
        code: ErrorCode.PROJECT_NOT_FOUND, 
        status: 404, 
        message: 'Project not found.' 
      };
    }

    // Mise à jour du nœud
    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    // Gestion du fichier
    const filePath = await getFilePath(project, nodeData.fileName);
    if (!validateFilePath(filePath)) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Invalid file path.' 
      };
    }

    // Vérifier les changements dans le fichier
    const hasChanges = await checkFileChanges(filePath, nodeData.code);
    if (hasChanges) {
      await writeFile(filePath, nodeData.code);
      fileCache.del(filePath); // Invalider le cache
      logger.info(`File updated: ${filePath}`);
    } else {
      logger.info('No changes in file content, skipping file write.');
    }

    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Récupère les fonctions accessibles pour un nœud spécifique.
 */
export const getAccessibleFunctions = async (req: Request, res: Response) => {
  const { project, nodeId } = req.query;

  try {
    if (!project || typeof project !== 'string' || !nodeId || typeof nodeId !== 'string') {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project and nodeId are required and must be strings.' 
      };
    }

    const node = await NodeModel.findOne({ project, id: nodeId });
    if (!node) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    const accessibleFunctions = node.data.exportedFunctions;
    res.json({ accessibleFunctions });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Met à jour un nœud spécifique.
 */
export const updateNode = async (req: Request, res: Response) => {
  const { project, nodeId, nodeData } = req.body;

  try {
    if (!project || !nodeId || !nodeData) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project, nodeId, and nodeData are required.' 
      };
    }

    // Validation des champs requis
    const requiredFields = ['label', 'fileName', 'code'];
    for (const field of requiredFields) {
      if (!nodeData[field]) {
        throw { 
          code: ErrorCode.VALIDATION_ERROR, 
          status: 400, 
          message: `Field '${field}' is required in nodeData.` 
        };
      }
    }

    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    const filePath = await getFilePath(project, nodeData.fileName);
    if (!validateFilePath(filePath)) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Invalid file path.' 
      };
    }

    await writeFile(filePath, nodeData.code);
    fileCache.del(filePath); // Invalider le cache
    
    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Liste tous les fichiers d'un projet.
 */
export const listFiles = async (req: Request, res: Response) => {
  const { project } = req.params;

  try {
    if (!project) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project is required.' 
      };
    }

    const isValidProject = await validateProject(project);
    if (!isValidProject) {
      throw { 
        code: ErrorCode.PROJECT_NOT_FOUND, 
        status: 404, 
        message: 'Project not found.' 
      };
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);
    const files = await getAllFiles(projectPath, ['node_modules'], 5);
    res.json({ files });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Fonction récursive pour obtenir tous les fichiers.
 */
async function getAllFiles(dir: string, exclude: string[] = [], maxDepth: number = 5): Promise<string[]> {
  if (maxDepth < 0) return [];
  
  const results: string[] = [];
  const list = await fs.readdir(dir, { withFileTypes: true });
  
  await Promise.all(list.map(async dirent => {
    if (exclude.includes(dirent.name)) return;
    
    const fullPath = path.join(dir, dirent.name);
    if (dirent.isDirectory()) {
      const subFiles = await getAllFiles(fullPath, exclude, maxDepth - 1);
      results.push(...subFiles);
    } else {
      results.push(path.relative(dir, fullPath));
    }
  }));

  return results;
}

// Export des types pour la documentation
export type { Request, Response, NextFunction };

---------
/// my-low-code-app/backend/src/controllers/gitController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import EdgeModel from '../models/Edge';
import logger from '../utils/logger';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import simpleGit, { SimpleGit, SimpleGitOptions, GitError } from 'simple-git';
import { ParserOptions } from '@babel/parser';
import { promisify } from 'util';
import { throttle } from 'lodash';

// Configuration et constantes
const execAsync = promisify(exec);
const CONCURRENT_LIMIT = 10;
const FILE_SIZE_LIMIT = 5 * 1024 * 1024; // 5MB

// Enum pour les codes d'erreur
enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  GIT_ERROR = 'GIT_ERROR',
  FILE_ERROR = 'FILE_ERROR',
  DB_ERROR = 'DB_ERROR'
}

// Configuration Git optimisée
const gitOptions: Partial<SimpleGitOptions> = {
  baseDir: process.cwd(),
  binary: 'git',
  maxConcurrentProcesses: 6,
  trimmed: false,
  timeout: {
    block: 30000 // 30 secondes
  }
};

const git: SimpleGit = simpleGit(gitOptions);

// Configuration Babel optimisée
const babelConfig: ParserOptions = {
  sourceType: 'module',
  plugins: [
    'typescript',
    'jsx',
    ['decorators', { legacy: true }]
  ] as any[],
  allowImportExportEverywhere: true,
  allowReturnOutsideFunction: true
};

// Interfaces
interface FileAnalysis {
  timestamp: number;
  data: {
    exports: string[];
    imports: string[];
  };
}

interface ProjectAnalysisResult {
  processedFiles: number;
  errors?: Array<{ file: string; error: string }>;
}

interface ProjectNode {
  project: string;
  id: string;
  type: string;
  position: { x: number; y: number };
  data: {
    label: string;
    fileName: string;
    imports: string[];
    code: string;
    exportedFunctions: string[];
    lintErrors: any[];
  };
}

interface ProjectEdge {
  project: string;
  id: string;
  source: string;
  target: string;
  animated: boolean;
  label: string;
}

// Validation des fichiers améliorée
const isValidFile = (fileName: string): boolean => {
  const invalidPatterns = [
    /\.log$/i,
    /\.(test|spec)\.(js|ts|jsx|tsx)$/i,
    /^(temp|tmp)\//,
    /node_modules/,
    /\.git/,
    /\.env/
  ];
  const maxPathLength = process.platform === 'win32' ? 260 : 4096;
  
  return !invalidPatterns.some(pattern => pattern.test(fileName)) &&
         fileName.length < maxPathLength &&
         !path.isAbsolute(fileName);
};

// Cache pour les fichiers analysés
const fileAnalysisCache = new Map<string, FileAnalysis>();

// Fonction d'extraction des fonctions exportées
async function extractExportedFunctions(filePath: string): Promise<string[]> {
  try {
    const stats = await fsPromises.stat(filePath);
    const cacheKey = `${filePath}:${stats.mtime.getTime()}`;
    const cached = fileAnalysisCache.get(cacheKey);

    if (cached) {
      return cached.data.exports;
    }

    if (stats.size > FILE_SIZE_LIMIT) {
      logger.warn(`File too large to analyze: ${filePath}`);
      return [];
    }

    const code = await fsPromises.readFile(filePath, 'utf-8');
    if (!code.trim()) {
      return [];
    }

    const exportedFunctions: string[] = [];
    try {
      const ast = parse(code, babelConfig);

      traverse(ast, {
        ExportNamedDeclaration(path) {
          if (path.node.declaration?.type === 'FunctionDeclaration') {
            const funcName = path.node.declaration.id?.name;
            if (funcName) exportedFunctions.push(funcName);
          }
        },
        ExportDefaultDeclaration(path) {
          if (path.node.declaration?.type === 'FunctionDeclaration') {
            const funcName = path.node.declaration.id?.name;
            if (funcName) exportedFunctions.push(funcName);
          }
        }
      });

      fileAnalysisCache.set(cacheKey, {
        timestamp: Date.now(),
        data: { exports: exportedFunctions, imports: [] }
      });

      return exportedFunctions;
    } catch (parseError) {
      logger.error(`Parse error in ${filePath}:`, parseError);
      return [];
    }
  } catch (error) {
    logger.error(`Error extracting functions from ${filePath}:`, error);
    return [];
  }
}

// Analyse des fichiers du projet
async function analyzeProjectFiles(projectPath: string, projectId: string): Promise<ProjectAnalysisResult> {
  const errors: Array<{ file: string; error: string }> = [];
  const processedFiles = new Set<string>();

  async function* findJsTsFiles(dir: string): AsyncGenerator<string> {
    const entries = await fsPromises.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        yield* findJsTsFiles(fullPath);
      } else if (entry.isFile() && /\.(js|ts|jsx|tsx)$/.test(entry.name)) {
        if (isValidFile(entry.name)) {
          yield fullPath;
        }
      }
    }
  }

  async function processBatch(files: string[]) {
    const nodes: ProjectNode[] = [];
    const edges: ProjectEdge[] = [];

    await Promise.all(files.map(async (filePath) => {
      try {
        if (processedFiles.has(filePath)) return;
        processedFiles.add(filePath);

        const stats = await fsPromises.stat(filePath);
        if (stats.size > FILE_SIZE_LIMIT) {
          throw new Error('File too large');
        }

        const content = await fsPromises.readFile(filePath, 'utf-8');
        if (!content.trim()) return;

        const exportedFunctions = await extractExportedFunctions(filePath);
        const relativeFilePath = path.relative(projectPath, filePath).replace(/\\/g, '/');
        
        const node: ProjectNode = {
          project: projectId,
          id: crypto.randomUUID(),
          type: 'code',
          position: { x: Math.random() * 800, y: Math.random() * 600 },
          data: {
            label: path.basename(filePath),
            fileName: relativeFilePath,
            imports: [],
            code: content,
            exportedFunctions,
            lintErrors: []
          }
        };

        try {
          const ast = parse(content, babelConfig);
          traverse(ast, {
            ImportDeclaration(path) {
              const importSource = path.node.source.value;
              node.data.imports.push(importSource);

              const targetPath = resolveImportPath(projectPath, filePath, importSource);
              if (targetPath) {
                edges.push({
                  project: projectId,
                  id: `${relativeFilePath}_to_${targetPath}`,
                  source: relativeFilePath,
                  target: targetPath,
                  animated: false,
                  label: 'imports'
                });
              }
            }
          });
        } catch (parseError) {
          logger.error(`Parse error in ${filePath}:`, parseError);
        }

        nodes.push(node);
      } catch (error: any) {
        errors.push({ file: filePath, error: error.message });
      }
    }));

    if (nodes.length > 0) {
      await NodeModel.bulkWrite(
        nodes.map(node => ({
          updateOne: {
            filter: { project: node.project, id: node.id },
            update: { $set: node },
            upsert: true
          }
        }))
      );
    }

    if (edges.length > 0) {
      await EdgeModel.bulkWrite(
        edges.map(edge => ({
          updateOne: {
            filter: { project: edge.project, id: edge.id },
            update: { $set: edge },
            upsert: true
          }
        }))
      );
    }
  }

  const filesBatch: string[] = [];
  for await (const file of findJsTsFiles(projectPath)) {
    filesBatch.push(file);
    if (filesBatch.length >= CONCURRENT_LIMIT) {
      await processBatch([...filesBatch]);
      filesBatch.length = 0;
    }
  }

  if (filesBatch.length > 0) {
    await processBatch(filesBatch);
  }

  return {
    processedFiles: processedFiles.size,
    errors: errors.length > 0 ? errors : undefined
  };
}

// Git handlers
export const pullFromGit = async (req: Request, res: Response) => {
  const { repoUrl } = req.body;

  if (!repoUrl || typeof repoUrl !== 'string') {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'URL du dépôt Git invalide'
    });
  }

  const projectName = path.basename(repoUrl, '.git')
    .replace(/[^a-zA-Z0-9-_]/g, '_');
  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    const projectExists = await fsPromises.access(projectPath)
      .then(() => true)
      .catch(() => false);

    if (projectExists) {
      await git.cwd(projectPath);
      const status = await git.status();
      
      if (!status.isClean()) {
        throw new Error('Working directory is not clean');
      }
      
      await git.pull(['--ff-only', '--quiet']);
    } else {
      await git.clone(repoUrl, projectPath, [
        '--depth', '1',
        '--single-branch',
        '--quiet'
      ]);
    }

    const project = await Project.findOneAndUpdate(
      { name: projectName },
      { name: projectName },
      { upsert: true, new: true }
    );

    const shouldInstall = await checkNeedsDependencyInstall(projectPath);
    if (shouldInstall) {
      await installDependencies(projectPath);
    }

    const analysisResult = await analyzeProjectFiles(projectPath, project._id.toString());

    res.json({
      message: 'Projet importé avec succès',
      projectName,
      analysis: analysisResult
    });
  } catch (error) {
    handleGitError(error, res);
  }
};

export const commitChanges = async (req: Request, res: Response) => {
  const { projectName, commitMessage } = req.body;

  if (!projectName || !commitMessage?.trim()) {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'Nom du projet et message de commit requis'
    });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    const status = await git.status();

    if (status.isClean()) {
      return res.json({ message: 'Aucun changement à commiter' });
    }

    await git.add('.');
    await git.commit(commitMessage.trim(), {
      '--no-verify': null,
      '--quiet': null
    });

    res.json({ message: 'Changements commités avec succès' });
  } catch (error) {
    handleGitError(error, res);
  }
};

export const pushChanges = async (req: Request, res: Response) => {
  const { projectName } = req.body;

  if (!projectName) {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'Nom du projet requis'
    });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    await git.push(['--quiet', '--force-with-lease']);
    
    res.json({ message: 'Changements poussés avec succès' });
  } catch (error) {
    handleGitError(error, res);
  }
};

// Utility functions
function handleGitError(error: unknown, res: Response) {
  logger.error('Git error:', error);
  
  if (error instanceof GitError) {
    res.status(400).json({
      code: ErrorCode.GIT_ERROR,
      message: 'Erreur Git',
      details: error.message
    });
  } else {
    res.status(500).json({
      code: ErrorCode.GIT_ERROR,
      message: 'Erreur interne',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

async function checkNeedsDependencyInstall(projectPath: string): Promise<boolean> {
  const packageLockPath = path.join(projectPath, 'package-lock.json');
  const nodeModulesPath = path.join(projectPath, 'node_modules');
  
  return !(await fsPromises.access(packageLockPath).then(() => true).catch(() => false) &&
           await fsPromises.access(nodeModulesPath).then(() => true).catch(() => false));
}

async function installDependencies(projectPath: string): Promise<void> {
  try {
    await execAsync('npm install --quiet', {
      cwd: projectPath,
      timeout: 300000, // 5 minutes
      maxBuffer: 10 * 1024 * 1024 // 10MB
    });
  } catch (error) {
    throw new Error(`Erreur d'installation des dépendances: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

function resolveImportPath(projectPath: string, currentFile: string, importPath: string): string | null {
  try {
    if (importPath.startsWith('.')) {
      const absolutePath = path.resolve(path.dirname(currentFile), importPath);
      return path.relative(projectPath, absolutePath).replace(/\\/g, '/');
    }
    return null;
  } catch {
    return null;
  }
}

---------
/// my-low-code-app/backend/src/controllers/graphController.ts

import { Request, Response } from 'express';
import { createClient } from '@redis/client';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import path from 'path';
import fs from 'fs/promises';
import logger from '../utils/logger';
import { getFilePath } from '../utils/fileUtils';

// Initialisation du client Redis
const redisClient = createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379'
});

redisClient.on('error', err => logger.error('Redis Client Error', err));

(async () => {
  await redisClient.connect();
})();

// Clés de cache
const CACHE_KEYS = {
  graph: (projectId: string) => `graph:${projectId}`,
  nodeFile: (projectId: string, nodeId: string) => `file:${projectId}:${nodeId}`
};

const CACHE_TTL = 3600; // 1 heure

export const getProjectGraph = async (req: Request, res: Response) => {
  const { project } = req.query;

  if (!project || typeof project !== 'string') {
    return res.status(400).json({ message: 'Project is required and must be a string.' });
  }

  try {
    // Vérifier le cache
    const cachedGraph = await redisClient.get(CACHE_KEYS.graph(project));
    if (cachedGraph) {
      logger.info(`Cache hit for project graph: ${project}`);
      return res.json({ graph: JSON.parse(cachedGraph) });
    }

    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    const [nodes, edges] = await Promise.all([
      NodeModel.find({ project: existingProject._id }),
      Edge.find({ project: existingProject._id })
    ]);

    const graph = { nodes, edges };
    
    // Mettre en cache
    await redisClient.set(CACHE_KEYS.graph(project), JSON.stringify(graph), {
      EX: CACHE_TTL
    });

    res.json({ graph });
  } catch (error) {
    logger.error('Error fetching project graph:', error);
    res.status(500).json({ message: 'Error fetching project graph.' });
  }
};

export const updateGraph = async (req: Request, res: Response) => {
  const { project, nodes, edges } = req.body;

  if (!project || (!nodes && !edges)) {
    return res.status(400).json({ message: 'Project, nodes, or edges are required.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Update nodes if provided
    if (nodes && nodes.length > 0) {
      const nodeOperations = nodes.map((node: any) => ({
        updateOne: {
          filter: { project: existingProject._id, id: node.id },
          update: { 
            project: existingProject._id,
            id: node.id,
            ...node,
          },
          upsert: true, // Create if not exists
        },
      }));

      await NodeModel.bulkWrite(nodeOperations);
      console.log('Nodes updated:', nodes.length);
    }

    // Update edges if provided
    if (edges && edges.length > 0) {
      const edgeOperations = edges.map((edge: any) => ({
        updateOne: {
          filter: { project: existingProject._id, id: edge.id },
          update: { 
            project: existingProject._id,
            id: edge.id,
            ...edge,
          },
          upsert: true,
        },
      }));

      await Edge.bulkWrite(edgeOperations);
      console.log('Edges updated:', edges.length);
    }

    // Invalider le cache du graphe
    await redisClient.del(CACHE_KEYS.graph(project));

    res.json({ message: 'Graph updated successfully.' });
  } catch (error) {
    console.error('Error updating graph:', error);
    res.status(500).json({ message: 'Error updating graph.', error: error.message });
  }
};

export const deleteNode = async (req: Request, res: Response) => {
  const { project, nodeId } = req.body;

  if (!project || !nodeId) {
    return res.status(400).json({ message: 'Project and nodeId are required.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    const nodeToDelete = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!nodeToDelete) {
      return res.status(404).json({ message: 'Node not found.' });
    }

    const filePath = path.join(__dirname, '..', 'projects', project, nodeToDelete.data.fileName);

    try {
      await fs.unlink(filePath);
      logger.info(`File deleted: ${filePath}`);
      // Supprimer du cache
      await redisClient.del(CACHE_KEYS.nodeFile(project, nodeId));
    } catch (error) {
      logger.warn(`File not found for deletion: ${filePath}`);
    }

    await NodeModel.deleteOne({ project: existingProject._id, id: nodeId });
    await Edge.deleteMany({ project: existingProject._id, $or: [{ source: nodeId }, { target: nodeId }] });

    // Invalider le cache du graphe
    await redisClient.del(CACHE_KEYS.graph(project));

    res.json({ message: 'Node and associated edges deleted successfully.' });
  } catch (error) {
    logger.error('Error deleting node:', error);
    res.status(500).json({ message: 'Error deleting node.' });
  }
};

export const cloneNode = async (req: Request, res: Response) => {
  const { project, nodeId, newNodeId } = req.body;

  if (!project || !nodeId || !newNodeId) {
    return res.status(400).json({ message: 'Project, nodeId, and newNodeId are required.' });
  }

  try {
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Vérifier d'abord le cache
    const cachedNode = await redisClient.get(CACHE_KEYS.nodeFile(project, nodeId));
    let nodeToClone;

    if (cachedNode) {
      nodeToClone = JSON.parse(cachedNode);
    } else {
      nodeToClone = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
      if (!nodeToClone) {
        return res.status(404).json({ message: 'Node to clone not found.' });
      }
    }

    const clonedNode = { ...nodeToClone.toObject(), id: newNodeId };
    clonedNode.position.x += 100;
    clonedNode.position.y += 100;
    clonedNode.data.label = `${clonedNode.data.label} (Clone)`;
    clonedNode.data.fileName = `${clonedNode.data.fileName.split('.').slice(0, -1).join('.')}_clone.${clonedNode.data.fileName.split('.').pop()}`;
    delete clonedNode._id;

    const newFilePath = path.join(__dirname, '..', 'projects', project, clonedNode.data.fileName);
    await fs.writeFile(newFilePath, clonedNode.data.code);
    logger.info(`Cloned file created: ${newFilePath}`);

    // Mettre en cache le nouveau nœud
    await redisClient.set(
      CACHE_KEYS.nodeFile(project, newNodeId),
      JSON.stringify(clonedNode),
      { EX: CACHE_TTL }
    );

    await new NodeModel(clonedNode).save();

    // Invalider le cache du graphe
    await redisClient.del(CACHE_KEYS.graph(project));

    res.json({ message: 'Node cloned successfully.', clonedNode });
  } catch (error) {
    logger.error('Error cloning node:', error);
    res.status(500).json({ message: 'Error cloning node.' });
  }
};
export const updateNode = async (req: Request, res: Response) => {
  const { project, node } = req.body;

  console.log('Project:', project);
  console.log('Node:', node);


  // Vérification de la structure correcte du nœud
  if (!project || !node || !node.id || !node.data || !node.data.fileName || !node.data.code) {
    return res.status(400).json({
      message: 'Project and node with valid id, fileName, and code are required.'
    });
  }

  logger.info('Received updateNode request:', req.body);

  const lockKey = `lock:${project}:update:${node.id}`;
  let lockAcquired: any = false;

  try {
    // Acquérir un verrou pour éviter les conflits d'écriture concurrents
    lockAcquired = await redisClient.set(lockKey, '1', {
      NX: true,
      EX: 60, // 60 secondes max
    });

    if (!lockAcquired) {
      return res.status(429).json({ message: 'Another update for this node is in progress' });
    }

    // Récupérer le projet
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Construire le chemin du fichier du nœud
    const filePath = await getFilePath(project, node.data.fileName);

    // Écrire le fichier de code
    try {
      await fs.writeFile(filePath, node.data.code);
      logger.info(`File written successfully: ${filePath}`);

      // Mettre en cache le contenu du fichier
      await redisClient.set(
        CACHE_KEYS.nodeFile(project, node.id),
        node.data.code,
        { EX: CACHE_TTL }
      );
    } catch (fsError: any) {
      logger.error(`Error writing file ${filePath}:`, fsError);
      throw fsError;
    }

    // Mettre à jour la base de données avec les informations du nœud
    await NodeModel.updateOne(
      { project: existingProject._id, id: node.id },
      {
        project: existingProject._id,
        id: node.id,
        type: node.type || 'code',
        position: node.position || { x: 0, y: 0 },
        data: {
          label: node.data.label || node.data.fileName,
          fileName: node.data.fileName,
          imports: node.data.imports || [],
          code: node.data.code,
          exportedFunctions: node.data.exportedFunctions || [],
          lintErrors: node.data.lintErrors || [],
        },
      },
      { upsert: true }
    );

    // Invalider le cache du graphe si nécessaire
    await redisClient.del(CACHE_KEYS.graph(project));

    res.json({ message: 'Node updated successfully.' });
  } catch (error) {
    logger.error('Error updating node:', error);
    res.status(500).json({ message: 'Error updating node.', error: error.message });
  } finally {
    if (lockAcquired) {
      await redisClient.del(lockKey); // Libérer le verrou
    }
  }
};


// Nettoyage lors de l'arrêt
process.on('SIGTERM', async () => {
  await redisClient.quit();
});

export default {
  getProjectGraph,
  updateNode,
  updateGraph,
  deleteNode,
  cloneNode
};

---------
/// my-low-code-app/backend/src/controllers/importController.ts

import { Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import logger from '../utils/logger';

/**
 * Configuration de Multer pour stocker les fichiers uploadés dans un dossier temporaire
 */
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

/**
 * Type pour les données du fichier de projet importé
 */
interface ImportedProject {
  projectName: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      fileName: string;
      imports: string[];
      code: string;
      exportedFunctions: string[];
      lintErrors?: any[];
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    animated?: boolean;
    label?: string;
  }>;
}

/**
 * Importe un projet depuis un fichier JSON
 * @param req - Requête Express avec le fichier uploadé
 * @param res - Réponse Express
 */
export const importProject = [
  upload.single('projectFile'),
  async (req: Request, res: Response) => {
    // Validation des données
    if (!req.file) {
      logger.error('No file uploaded for project import.');
      return res.status(400).json({ message: 'Aucun fichier uploadé.' });
    }

    try {
      const projectData: ImportedProject = JSON.parse(req.file.buffer.toString('utf-8'));

      // Valider la structure du fichier
      const schema = Joi.object({
        projectName: Joi.string().alphanum().min(3).max(30).required(),
        nodes: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            type: Joi.string().required(),
            position: Joi.object({
              x: Joi.number().required(),
              y: Joi.number().required(),
            }).required(),
            data: Joi.object({
              label: Joi.string().required(),
              fileName: Joi.string().required(),
              imports: Joi.array().items(Joi.string()).required(),
              code: Joi.string().required(),
              exportedFunctions: Joi.array().items(Joi.string()).required(),
              lintErrors: Joi.array().items(Joi.any()).optional(),
            }).required(),
          })
        ).required(),
        edges: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            source: Joi.string().required(),
            target: Joi.string().required(),
            animated: Joi.boolean().optional(),
            label: Joi.string().optional(),
          })
        ).required(),
      });

      const { error } = schema.validate(projectData);
      if (error) {
        logger.error(`Validation error during project import: ${error.details[0].message}`);
        return res.status(400).json({ message: error.details[0].message });
      }

      const { projectName, nodes, edges } = projectData;

      // Vérifier si le projet existe déjà
      const existingProject = await Project.findOne({ name: projectName });
      if (existingProject) {
        logger.warn(`Import project failed: Project "${projectName}" already exists.`);
        return res.status(400).json({ message: 'Le projet existe déjà.' });
      }

      // Créer le dossier du projet
      const projectPath = path.join(__dirname, '..', 'projects', projectName);
      await fs.mkdir(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);

      // Créer les fichiers des nœuds
      for (const node of nodes) {
        const filePath = path.join(projectPath, node.data.fileName);
        await fs.writeFile(filePath, node.data.code);
        logger.info(`File created for node "${node.id}" at: ${filePath}`);
      }

      // Initialiser un package.json
      await fs.writeFile(path.join(projectPath, 'package.json'), JSON.stringify({
        name: projectName,
        version: "1.0.0",
        main: "index.js",
        scripts: {
          start: "node index.js"
        },
        dependencies: {}
      }, null, 2));
      logger.info(`package.json created at: ${path.join(projectPath, 'package.json')}`);

      // Enregistrer le projet dans la base de données
      const newProject = new Project({
        name: projectName,
      });

      const savedProject = await newProject.save();
      logger.info(`Project "${projectName}" saved to database.`);

      // Enregistrer les nœuds dans la base de données
      for (const node of nodes) {
        const newNode = new NodeModel({
          project: savedProject._id,
          id: node.id,
          type: node.type,
          position: node.position,
          data: node.data,
        });
        await newNode.save();
        logger.info(`Node "${node.id}" saved to database.`);
      }

      // Vous pouvez également enregistrer les arêtes si vous avez un modèle pour les arêtes

      res.status(201).json({ message: 'Projet importé avec succès.', project: savedProject });
    } catch (error: any) {
      logger.error(`Error during project import: ${error.message}`);
      res.status(500).json({ message: 'Erreur lors de l\'importation du projet.', error: error.message });
    }
  }
];


---------
/// my-low-code-app/backend/src/controllers/nodeController.ts

import { Request, Response } from 'express';
import { getFilePath, writeFile } from '../utils/fileUtils';
import NodeModel from '../models/Node';

interface NodeData {
  label: string;
  fileName: string;
  code: string;
  [key: string]: any;
}

interface UpdateNodeRequest {
  project: string;
  nodeId: string;
  nodeData: NodeData;
}

// Validation des données d'entrée
const validateInput = (data: Partial<UpdateNodeRequest>): string | null => {
  const { project, nodeId, nodeData } = data;
  
  if (!project || !nodeId || !nodeData) {
    return 'Project, nodeId, and nodeData are required.';
  }

  const requiredFields = ['label', 'fileName', 'code'];
  const missingField = requiredFields.find(field => !nodeData[field]);
  
  if (missingField) {
    return `Field '${missingField}' is required in nodeData.`;
  }

  return null;
};

// Mise à jour du node dans la base de données
const updateNodeInDb = async (
  project: string, 
  nodeId: string, 
  nodeData: NodeData
) => {
  const updatedNode = await NodeModel.findOneAndUpdate(
    { project, id: nodeId },
    { $set: { data: nodeData } },
    { new: true, runValidators: true }
  );

  if (!updatedNode) {
    throw new Error('Node not found.');
  }

  return updatedNode;
};

// Écriture du code dans le système de fichiers
const writeCodeToFile = async (
  project: string, 
  fileName: string, 
  code: string
): Promise<void> => {
  const filePath = getFilePath(project, fileName);
  await writeFile(filePath, code);
};

// Controller principal
export const updateNode = async (req: Request, res: Response): Promise<Response> => {
  const { project, nodeId, nodeData } = req.body;

  try {
    // Validation
    const validationError = validateInput(req.body);
    if (validationError) {
      return res.status(400).json({ message: validationError });
    }

    // Mise à jour en base de données
    const updatedNode = await updateNodeInDb(project, nodeId, nodeData);

    // Écriture du fichier
    await writeCodeToFile(project, nodeData.fileName, nodeData.code);

    return res.json({
      message: 'Node updated successfully.',
      node: updatedNode
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    const statusCode = errorMessage === 'Node not found.' ? 404 : 500;

    return res.status(statusCode).json({
      message: 'Error updating node or writing file.',
      error: errorMessage
    });
  }
};

---------
/// my-low-code-app/backend/src/controllers/projectController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import simpleGit, { SimpleGit } from 'simple-git';
import logger from '../utils/logger';
import { analyzeFile } from '../utils/fileAnalyzer';

export async function analyzeProject(req: Request, res: Response) {
  const { projectId } = req.params;
  const projectPath = path.join(__dirname, '..', 'projects', projectId);

  try {
    // Vérifier que le projet existe
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ 
        message: 'Projet non trouvé',
        error: 'Project not found' 
      });
    }

    // Récupérer tous les fichiers .js et .ts
    const files = await getAllJsTsFiles(projectPath);
    
    // Analyser chaque fichier
    const analysisPromises = files.map(file => 
      analyzeFile(file, projectId, projectPath)
    );

    const results = await Promise.all(analysisPromises);

    // Compiler les résultats
    const nodes = results.flatMap(result => result.nodes);
    
    res.json({
      message: 'Analyse du projet terminée avec succès',
      projectId,
      nodesCount: nodes.length
    });

  } catch (error: any) {
    logger.error(`Erreur lors de l'analyse du projet ${projectId}: ${error.message}`);
    res.status(500).json({ 
      message: 'Erreur lors de l\'analyse du projet',
      error: error.message 
    });
  }
}

async function getAllJsTsFiles(dirPath: string): Promise<string[]> {
  const files: string[] = [];
  async function scan(currentPath: string) {
    const entries = await fs.promises.readdir(currentPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(currentPath, entry.name);
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        await scan(fullPath);
      } else if (
        entry.isFile() && 
        (entry.name.endsWith('.js') || entry.name.endsWith('.ts'))
      ) {
        files.push(fullPath);
      }
    }
  }

  await scan(dirPath);
  return files;
}




// Initialiser simple-git avec l'option de journalisation
const git: SimpleGit = simpleGit();

/**
 * Crée un nouveau projet.
 * @param req - Requête Express contenant projectCode, projectName et gitRepo dans le corps.
 * @param res - Réponse Express.
 */
export const createProject = async (req: Request, res: Response) => {
  const schema = Joi.object({
    projectCode: Joi.string().required(),
    projectName: Joi.string().alphanum().min(3).max(30).required(),
    gitRepo: Joi.string().uri().optional(), // Ajouter un champ pour l'URL du dépôt Git
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { projectCode, projectName, gitRepo } = req.body;

  try {
    // Vérifier si le projet existe déjà
    const existingProject = await Project.findOne({ name: projectName });
    if (existingProject) {
      logger.warn(`Project creation failed: Project "${projectName}" already exists.`);
      return res.status(400).json({ message: 'Le projet existe déjà.' });
    }

    // Créer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);
    }

    // Initialiser Git si un dépôt Git est fourni
    if (gitRepo) {
      try {
        await git.clone(gitRepo, projectPath);
        logger.info(`Git repository cloned from ${gitRepo} into ${projectPath}`);
      } catch (gitError: any) {
        logger.error(`Failed to clone Git repository: ${gitError.message}`);
        return res.status(500).json({ message: 'Erreur lors du clonage du dépôt Git.', error: gitError.message });
      }
    }

    // Créer le fichier principal (par exemple, index.ts)
    const mainFilePath = path.join(projectPath, 'index.ts');
    fs.writeFileSync(mainFilePath, projectCode);
    logger.info(`Main file created at: ${mainFilePath}`);

    // Initialiser un package.json
    exec('npm init -y', { cwd: projectPath }, async (err, stdout, stderr) => {
      if (err) {
        logger.error(`Error initializing npm: ${err.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'initialisation du projet.' });
      }

      logger.info(`npm initialized for project "${projectName}".`);

      try {
        // Enregistrer le projet dans la base de données
        const newProject = new Project({
          name: projectName,
        });

        const savedProject = await newProject.save();
        logger.info(`Project "${projectName}" saved to database.`);

        res.status(201).json({ message: 'Projet créé avec succès.', project: savedProject });
      } catch (saveError: any) {
        logger.error(`Error saving project to database: ${saveError.message}`);
        res.status(500).json({ message: 'Erreur lors de la création du projet.', error: saveError.message });
      }
    });

  } catch (error: any) {
    logger.error(`Error creating project: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la création du projet.', error: error.message });
  }
};

/**
 * Récupère la liste des projets.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const getProjects = async (req: Request, res: Response) => {
  try {
    const projects = await Project.find().select('name createdAt');
    logger.info('Fetched list of projects.');
    res.json(projects);
  } catch (error: any) {
    logger.error(`Error fetching projects: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la récupération des projets.', error: error.message });
  }
};

/**
 * Installe un package npm dans un projet spécifique.
 * @param req - Requête Express contenant project et packageName dans le corps.
 * @param res - Réponse Express.
 */
export const installPackage = async (req: Request, res: Response) => {
  const schema = Joi.object({
    project: Joi.string().required(),
    packageName: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { project, packageName } = req.body;

  try {
    // Trouver le projet dans la base de données
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      logger.warn(`Install package failed: Project "${project}" not found.`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);

    // Vérifier si le dossier du projet existe
    if (!fs.existsSync(projectPath)) {
      logger.error(`Project directory does not exist: ${projectPath}`);
      return res.status(400).json({ message: 'Le dossier du projet n\'existe pas.' });
    }

    logger.info(`Installing package "${packageName}" in project "${project}".`);

    // Exécuter la commande npm install
    exec(`npm install ${packageName}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Error installing package: ${error.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'installation du package.', stderr: stderr });
      }

      if (stderr) {
        logger.warn(`npm stderr: ${stderr}`);
        // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
      }

      logger.info(`npm stdout: ${stdout}`);
      res.json({ message: `Package "${packageName}" installé avec succès.`, stdout, stderr });
    });
  } catch (error: any) {
    logger.error(`Error installing package: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de l\'installation du package.', error: error.message });
  }
};

export const deleteProject = async (req: Request, res: Response) => {
  const { projectName } = req.params;
  logger.info(`Attempting to delete project: ${projectName}`);

  try {
    // Supprimer le projet de la base de données
    const project = await Project.findOneAndDelete({ name: projectName });
    if (!project) {
      logger.warn(`Project not found: ${projectName}`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    logger.info(`Project "${projectName}" deleted from database.`);

    // Supprimer tous les nœuds et arêtes associés
    await NodeModel.deleteMany({ project: project._id });
    await Edge.deleteMany({ project: project._id });
    logger.info(`Associated nodes and edges deleted for project "${projectName}".`);

    // Supprimer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    logger.info(`Project path to delete: ${projectPath}`);

    await fs.promises.rm(projectPath, { recursive: true, force: true });
    logger.info(`Project directory "${projectPath}" deleted successfully.`);

    res.json({ message: 'Projet supprimé avec succès.' });
  } catch (error: any) {
    logger.error(`Error deleting project "${projectName}": ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la suppression du projet.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/middleware/auth.ts

// backend/src/middleware/auth.ts

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

interface JwtPayload {
  userId: string;
  // Ajoutez d'autres propriétés si nécessaire
}

// Extension de l'interface Request pour inclure user
declare module 'express-serve-static-core' {
  interface Request {
    user?: JwtPayload;
  }
}

export const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (authHeader) {
    // Le format attendu est "Bearer <token>"
    const token = authHeader.split(' ')[1];

    jwt.verify(token, SECRET_KEY, (err, payload) => {
      if (err) {
        logger.warn('Invalid JWT token');
        return res.sendStatus(403); // Forbidden
      }

      // Vous pouvez ajouter le payload à la requête pour une utilisation future
      req.user = payload as JwtPayload;
      next();
    });
  } else {
    logger.warn('No Authorization header provided');
    res.sendStatus(401); // Unauthorized
  }
};


---------
/// my-low-code-app/backend/src/middleware/errorHandler.ts

import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  logger.error(`Unhandled Error: ${err.message}`);
  res.status(500).json({ message: 'Internal Server Error', error: err.message });
};


---------
/// my-low-code-app/backend/src/models/Edge.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IEdge extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  source: string;
  target: string;
  animated: boolean;
  label: string;
}

const EdgeSchema: Schema = new Schema({
  project: { 
    type: Schema.Types.ObjectId, 
    ref: 'Project', 
    required: true 
  },
  id: { 
    type: String, 
    required: true 
  },
  source: { 
    type: String, 
    required: true 
  },
  target: { 
    type: String, 
    required: true 
  },
  animated: { 
    type: Boolean, 
    default: false 
  },
  label: { 
    type: String, 
    default: 'connects to' 
  }
});

export default mongoose.model<IEdge>('Edge', EdgeSchema);

---------
/// my-low-code-app/backend/src/models/Node.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface INodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
  lintErrors?: any[];
}

export interface INode extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  type: string;
  position: {
    x: number;
    y: number;
  };
  data: INodeData;
}

const NodeSchema: Schema = new Schema({
  project: { 
    type: String, 
    required: true 
  },
  id: { 
    type: String, 
    required: true 
  },
  type: { 
    type: String, 
    required: true 
  },
  position: {
    x: { type: Number, required: true, default: 0 },
    y: { type: Number, required: true, default: 0 },
  },
  data: {
    label: { type: String, required: true },
    fileName: { type: String, required: true },
    imports: { type: [String], default: [] },
    code: { type: String, required: true },
    exportedFunctions: { type: [String], default: [] },
    lintErrors: { type: [Schema.Types.Mixed], default: [] },
  },
});

export default mongoose.model<INode>('Node', NodeSchema);

---------
/// my-low-code-app/backend/src/models/Project.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IProject extends Document {
  name: string;
  createdAt: Date;
}

const ProjectSchema: Schema = new Schema({
  name: { 
    type: String, 
    required: true,
    unique: true 
  },
  createdAt: { 
    type: Date, 
    default: Date.now 
  }
});

export default mongoose.model<IProject>('Project', ProjectSchema);

---------
/// my-low-code-app/backend/src/models/User.ts

import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends Document {
  username: string;
  password: string;
  comparePassword: (candidatePassword: string) => Promise<boolean>;
}

const UserSchema: Schema = new Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

// Middleware pour hacher le mot de passe avant de sauvegarder
UserSchema.pre<IUser>('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(this.password, salt);
    this.password = hashed;
    next();
  } catch (err) {
    next(err as any);
  }
});

// Méthode pour comparer les mots de passe
UserSchema.methods.comparePassword = function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/context.ts

// backend/src/context.ts

import { parse } from '@babel/parser';
import traverse from '@babel/traverse';

export class Context {
  [key: string]: any;

  constructor(exportedFunctions: { [key: string]: Function }) {
    for (const funcName in exportedFunctions) {
      if (exportedFunctions.hasOwnProperty(funcName)) {
        this[funcName] = exportedFunctions[funcName];
      }
    }
  }

  static extractExportedFunctions(code: string): string[] {
    const exportedFunctions: string[] = [];
    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      ExportNamedDeclaration(path) {
        const { declaration } = path.node;
        if (declaration && declaration.type === 'FunctionDeclaration') {
          const funcName = declaration.id?.name;
          if (funcName) {
            exportedFunctions.push(funcName);
          }
        }
      },
      ExportSpecifier(path) {
        const exportedNode = path.node.exported;
        const funcName = 'name' in exportedNode ? exportedNode.name : exportedNode.value;
        exportedFunctions.push(funcName);
      },
    });

    return exportedFunctions;
  }
}


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/authController.ts

// backend/src/controllers/authController.ts

import { Request, Response } from 'express';
import User, { IUser } from '../models/User';
import Joi from 'joi';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

/**
 * Inscription d'un nouvel utilisateur
 */
export const register = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    password: Joi.string().min(6).required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Registration validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Vérifier si l'utilisateur existe déjà
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      logger.warn(`Registration failed: Username "${username}" already exists.`);
      return res.status(400).json({ message: 'Username already exists.' });
    }

    // Créer un nouvel utilisateur
    const newUser = new User({ username, password });
    await newUser.save();

    logger.info(`User "${username}" registered successfully.`);
    res.status(201).json({ message: 'User registered successfully.' });
  } catch (error: any) {
    logger.error(`Error during registration: ${error.message}`);
    res.status(500).json({ message: 'Registration failed.', error: error.message });
  }
};

/**
 * Connexion d'un utilisateur existant
 */
export const login = async (req: Request, res: Response) => {
  const schema = Joi.object({
    username: Joi.string().required(),
    password: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Login validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { username, password } = req.body;

  try {
    // Trouver l'utilisateur
    const user = await User.findOne({ username });
    if (!user) {
      logger.warn(`Login failed: Username "${username}" not found.`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Comparer les mots de passe
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      logger.warn(`Login failed: Incorrect password for username "${username}".`);
      return res.status(400).json({ message: 'Invalid username or password.' });
    }

    // Créer un token JWT
    const token = jwt.sign({ userId: user._id }, SECRET_KEY, { expiresIn: '1h' });

    logger.info(`User "${username}" logged in successfully.`);
    res.json({ message: 'Login successful.', token });
  } catch (error: any) {
    logger.error(`Error during login: ${error.message}`);
    res.status(500).json({ message: 'Login failed.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/devServerController.ts

// backend/src/controllers/devServerController.ts

import { Request, Response } from 'express';
import { exec, ChildProcess } from 'child_process';
import path from 'path';
import fs from 'fs/promises';
import portfinder from 'portfinder';
import logger from '../utils/logger'; // Assurez-vous d'avoir configuré un logger, par exemple avec winston

let devServerProcess: ChildProcess | null = null;

/**
 * Démarre un serveur de développement pour un projet donné.
 * @param req - Requête Express contenant le nom du projet dans le corps.
 * @param res - Réponse Express.
 */
export const startDevServer = async (req: Request, res: Response) => {
  const { project } = req.body;

  if (!project) {
    logger.error('Error: Project is required to start the development server.');
    return res.status(400).json({ message: 'Project is required.' });
  }

  if (devServerProcess) {
    logger.warn('Attempted to start development server, but one is already running.');
    return res.status(400).json({ message: 'Development server is already running.' });
  }

  const projectPath = path.join(__dirname, '..', 'projects', project);

  try {
    // Vérifier si le dossier du projet existe
    await fs.access(projectPath);
    logger.info(`Starting development server for project: ${project} at path: ${projectPath}`);
  } catch (error) {
    logger.error(`Project directory does not exist: ${projectPath}`);
    return res.status(404).json({ message: 'Project directory does not exist.' });
  }

  try {
    // Trouver un port libre à partir de 4000
    const port = await portfinder.getPortPromise({ port: 4000 });

    // Commande pour démarrer le serveur de développement (par exemple, avec nodemon)
    const command = `npx nodemon index.js`; // Assurez-vous que 'index.js' est le fichier d'entrée de votre projet

    devServerProcess = exec(`PORT=${port} ${command}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Development server error: ${error.message}`);
        return;
      }
      if (stderr) {
        logger.error(`Development server stderr: ${stderr}`);
        return;
      }
      logger.info(`Development server stdout: ${stdout}`);
    });

    // Gestion de la sortie du processus
    devServerProcess.on('exit', (code, signal) => {
      logger.info(`Development server exited with code ${code} and signal ${signal}`);
      devServerProcess = null;
    });

    logger.info(`Development server started successfully on port ${port}`);
    res.json({ message: 'Development server started successfully.', port });
  } catch (error: any) {
    logger.error(`Failed to start development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to start development server.', error: error.message });
  }
};

/**
 * Arrête le serveur de développement en cours.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const stopDevServer = async (req: Request, res: Response) => {
  if (!devServerProcess) {
    logger.warn('Attempted to stop development server, but none is running.');
    return res.status(400).json({ message: 'Development server is not running.' });
  }

  try {
    devServerProcess.kill();
    logger.info('Development server stopped successfully.');
    devServerProcess = null;
    res.json({ message: 'Development server stopped successfully.' });
  } catch (error: any) {
    logger.error(`Failed to stop development server: ${error.message}`);
    res.status(500).json({ message: 'Failed to stop development server.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/executeController.ts

import { Request, Response } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs/promises';

export const executeNode = async (req: Request, res: Response) => {
  const { project, nodeId } = req.body;

  if (!project || !nodeId) {
    console.log('Error: Missing project or nodeId');
    return res.status(400).json({ message: 'Project and nodeId are required.' });
  }

  try {
    // Find the project
    console.log(`Looking for project: ${project}`);
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      console.log('Error: Project not found');
      return res.status(404).json({ message: 'Project not found.' });
    }

    // Find the node
    console.log(`Looking for node with ID: ${nodeId}`);
    const node = await NodeModel.findOne({ project: existingProject._id, id: nodeId });
    if (!node) {
      console.log('Error: Node not found');
      return res.status(404).json({ message: 'Node not found.' });
    }

    // Resolve the path to the node file
    const projectPath = path.join(__dirname, '..', 'projects', project);
    const filePath = path.join(projectPath, node.data.fileName);
    console.log(`Resolved file path: ${filePath}`);

    // Check if the file exists
    try {
      await fs.access(filePath);
    } catch (error) {
      console.log('Error: Node file does not exist');
      return res.status(404).json({ message: 'Node file does not exist.' });
    }

    // Execute the file
    const command = `node ${filePath}`;
    console.log(`Executing command: ${command}`);
    exec(command, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing node: ${error.message}`);
        return res.status(500).json({ message: 'Error executing node.', error: error.message });
      }

      console.log('Node executed successfully');
      console.log(`stdout: ${stdout}`);
      console.log(`stderr: ${stderr}`);

      res.json({
        message: 'Node executed successfully.',
        stdout: stdout.trim(),
        stderr: stderr.trim(),
      });
    });

  } catch (error: any) {
    console.error('Error during node execution:', error);
    res.status(500).json({ message: 'Error during node execution.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/fileController.ts

// backend/src/controllers/fileController.ts

import { Request, Response, NextFunction } from 'express';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import { getFilePath, writeFile } from '../utils/fileUtils';
import fs from 'fs/promises';
import Joi from 'joi';
import logger from '../utils/logger';
import path from 'path';
import rateLimit from 'express-rate-limit';
import compression from 'compression';
import NodeCache from 'node-cache';

// Configuration du cache
const fileCache = new NodeCache({ stdTTL: 300 }); // 5 minutes TTL

// Enum pour les codes d'erreur
enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NODE_NOT_FOUND = 'NODE_NOT_FOUND',
  FILE_WRITE_ERROR = 'FILE_WRITE_ERROR',
  FILE_READ_ERROR = 'FILE_READ_ERROR',
  PROJECT_NOT_FOUND = 'PROJECT_NOT_FOUND',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

// Configuration du rate limiter
export const updateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limite chaque IP à 100 requêtes par fenêtre
  message: 'Too many update requests from this IP'
});

// Configuration de la compression
export const compressionMiddleware = compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  },
  threshold: 1024 // Compresse seulement les réponses plus grandes que 1KB
});

// Middleware de performance
export const performanceMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = process.hrtime();
  res.on('finish', () => {
    const [seconds, nanoseconds] = process.hrtime(start);
    const duration = seconds * 1000 + nanoseconds / 1e6;
    logger.info(`${req.method} ${req.url} - ${duration.toFixed(2)}ms`);
  });
  next();
};

// Schémas de validation
const NODE_DATA_SCHEMA = Joi.object({
  project: Joi.string().required(),
  nodeId: Joi.string().required(),
  nodeData: Joi.object({
    label: Joi.string().required(),
    fileName: Joi.string().required(),
    imports: Joi.array().items(Joi.string()).required(),
    code: Joi.string().required(),
    exportedFunctions: Joi.array().items(Joi.string()).required(),
    lintErrors: Joi.array().items(Joi.any()).optional(),
  }).required(),
}).cache();

// Gestionnaire d'erreurs central
const handleError = (error: any, res: Response) => {
  const errorCode = error.code || ErrorCode.UNKNOWN_ERROR;
  logger.error(`${errorCode}: ${error.message}`);
  const status = error.status || 500;
  res.status(status).json({
    code: errorCode,
    message: error.message,
    details: error.details || null
  });
};

// Fonctions utilitaires
const validateFilePath = (filePath: string): boolean => {
  const normalizedPath = path.normalize(filePath);
  const projectRoot = path.normalize(path.join(__dirname, '..', 'projects'));
  return normalizedPath.startsWith(projectRoot) && !normalizedPath.includes('..');
};

const validateProject = async (project: string): Promise<boolean> => {
  try {
    const projectExists = await Project.exists({ name: project });
    if (!projectExists) return false;
    
    const projectPath = path.join(__dirname, '..', 'projects', project);
    await fs.access(projectPath);
    
    return true;
  } catch (error) {
    logger.error(`Project validation error: ${error}`);
    return false;
  }
};

const checkFileChanges = async (filePath: string, newContent: string): Promise<boolean> => {
  try {
    const fileExists = await fs.access(filePath)
      .then(() => true)
      .catch(() => false);
    
    if (!fileExists) return true;

    const currentContent = await fs.readFile(filePath, 'utf8');
    return currentContent !== newContent;
  } catch (error) {
    logger.error(`Error checking file changes: ${error}`);
    return true;
  }
};

const getCachedFile = async (filePath: string): Promise<string | null> => {
  const cached = fileCache.get<string>(filePath);
  if (cached) return cached;
  
  try {
    const content = await fs.readFile(filePath, 'utf8');
    fileCache.set(filePath, content);
    return content;
  } catch (error) {
    logger.error(`Cache miss error: ${error}`);
    return null;
  }
};

/**
 * Met à jour un fichier de nœud spécifique dans un projet.
 */
export const updateFile = async (req: Request, res: Response) => {
  const { project, nodeId, nodeData } = req.body;

  try {
    // Validation des données entrantes
    const { error } = NODE_DATA_SCHEMA.validate({ project, nodeId, nodeData });
    if (error) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: error.details[0].message 
      };
    }

    // Validation du projet
    const isValidProject = await validateProject(project);
    if (!isValidProject) {
      throw { 
        code: ErrorCode.PROJECT_NOT_FOUND, 
        status: 404, 
        message: 'Project not found.' 
      };
    }

    // Mise à jour du nœud
    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    // Gestion du fichier
    const filePath = await getFilePath(project, nodeData.fileName);
    if (!validateFilePath(filePath)) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Invalid file path.' 
      };
    }

    // Vérifier les changements dans le fichier
    const hasChanges = await checkFileChanges(filePath, nodeData.code);
    if (hasChanges) {
      await writeFile(filePath, nodeData.code);
      fileCache.del(filePath); // Invalider le cache
      logger.info(`File updated: ${filePath}`);
    } else {
      logger.info('No changes in file content, skipping file write.');
    }

    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Récupère les fonctions accessibles pour un nœud spécifique.
 */
export const getAccessibleFunctions = async (req: Request, res: Response) => {
  const { project, nodeId } = req.query;

  try {
    if (!project || typeof project !== 'string' || !nodeId || typeof nodeId !== 'string') {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project and nodeId are required and must be strings.' 
      };
    }

    const node = await NodeModel.findOne({ project, id: nodeId });
    if (!node) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    const accessibleFunctions = node.data.exportedFunctions;
    res.json({ accessibleFunctions });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Met à jour un nœud spécifique.
 */
export const updateNode = async (req: Request, res: Response) => {
  const { project, nodeId, nodeData } = req.body;

  try {
    if (!project || !nodeId || !nodeData) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project, nodeId, and nodeData are required.' 
      };
    }

    // Validation des champs requis
    const requiredFields = ['label', 'fileName', 'code'];
    for (const field of requiredFields) {
      if (!nodeData[field]) {
        throw { 
          code: ErrorCode.VALIDATION_ERROR, 
          status: 400, 
          message: `Field '${field}' is required in nodeData.` 
        };
      }
    }

    const updatedNode = await NodeModel.findOneAndUpdate(
      { project, id: nodeId },
      { $set: { data: nodeData } },
      { new: true, runValidators: true }
    );

    if (!updatedNode) {
      throw { 
        code: ErrorCode.NODE_NOT_FOUND, 
        status: 404, 
        message: 'Node not found.' 
      };
    }

    const filePath = await getFilePath(project, nodeData.fileName);
    if (!validateFilePath(filePath)) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Invalid file path.' 
      };
    }

    await writeFile(filePath, nodeData.code);
    fileCache.del(filePath); // Invalider le cache
    
    res.json({ message: 'Node updated successfully.', node: updatedNode });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Liste tous les fichiers d'un projet.
 */
export const listFiles = async (req: Request, res: Response) => {
  const { project } = req.params;

  try {
    if (!project) {
      throw { 
        code: ErrorCode.VALIDATION_ERROR, 
        status: 400, 
        message: 'Project is required.' 
      };
    }

    const isValidProject = await validateProject(project);
    if (!isValidProject) {
      throw { 
        code: ErrorCode.PROJECT_NOT_FOUND, 
        status: 404, 
        message: 'Project not found.' 
      };
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);
    const files = await getAllFiles(projectPath, ['node_modules'], 5);
    res.json({ files });
  } catch (error: any) {
    handleError(error, res);
  }
};

/**
 * Fonction récursive pour obtenir tous les fichiers.
 */
async function getAllFiles(dir: string, exclude: string[] = [], maxDepth: number = 5): Promise<string[]> {
  if (maxDepth < 0) return [];
  
  const results: string[] = [];
  const list = await fs.readdir(dir, { withFileTypes: true });
  
  await Promise.all(list.map(async dirent => {
    if (exclude.includes(dirent.name)) return;
    
    const fullPath = path.join(dir, dirent.name);
    if (dirent.isDirectory()) {
      const subFiles = await getAllFiles(fullPath, exclude, maxDepth - 1);
      results.push(...subFiles);
    } else {
      results.push(path.relative(dir, fullPath));
    }
  }));

  return results;
}

// Export des types pour la documentation
export type { Request, Response, NextFunction };

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/gitController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import EdgeModel from '../models/Edge';
import logger from '../utils/logger';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import simpleGit, { SimpleGit, SimpleGitOptions, GitError } from 'simple-git';
import { ParserOptions } from '@babel/parser';
import { promisify } from 'util';
import { throttle } from 'lodash';

// Configuration et constantes
const execAsync = promisify(exec);
const CONCURRENT_LIMIT = 10;
const FILE_SIZE_LIMIT = 5 * 1024 * 1024; // 5MB

// Enum pour les codes d'erreur
enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  GIT_ERROR = 'GIT_ERROR',
  FILE_ERROR = 'FILE_ERROR',
  DB_ERROR = 'DB_ERROR'
}

// Configuration Git optimisée
const gitOptions: Partial<SimpleGitOptions> = {
  baseDir: process.cwd(),
  binary: 'git',
  maxConcurrentProcesses: 6,
  trimmed: false,
  timeout: {
    block: 30000 // 30 secondes
  }
};

const git: SimpleGit = simpleGit(gitOptions);

// Configuration Babel optimisée
const babelConfig: ParserOptions = {
  sourceType: 'module',
  plugins: [
    'typescript',
    'jsx',
    ['decorators', { legacy: true }]
  ] as any[],
  allowImportExportEverywhere: true,
  allowReturnOutsideFunction: true
};

// Interfaces
interface FileAnalysis {
  timestamp: number;
  data: {
    exports: string[];
    imports: string[];
  };
}

interface ProjectAnalysisResult {
  processedFiles: number;
  errors?: Array<{ file: string; error: string }>;
}

interface ProjectNode {
  project: string;
  id: string;
  type: string;
  position: { x: number; y: number };
  data: {
    label: string;
    fileName: string;
    imports: string[];
    code: string;
    exportedFunctions: string[];
    lintErrors: any[];
  };
}

interface ProjectEdge {
  project: string;
  id: string;
  source: string;
  target: string;
  animated: boolean;
  label: string;
}

// Validation des fichiers améliorée
const isValidFile = (fileName: string): boolean => {
  const invalidPatterns = [
    /\.log$/i,
    /\.(test|spec)\.(js|ts|jsx|tsx)$/i,
    /^(temp|tmp)\//,
    /node_modules/,
    /\.git/,
    /\.env/
  ];
  const maxPathLength = process.platform === 'win32' ? 260 : 4096;
  
  return !invalidPatterns.some(pattern => pattern.test(fileName)) &&
         fileName.length < maxPathLength &&
         !path.isAbsolute(fileName);
};

// Cache pour les fichiers analysés
const fileAnalysisCache = new Map<string, FileAnalysis>();

// Fonction d'extraction des fonctions exportées
async function extractExportedFunctions(filePath: string): Promise<string[]> {
  try {
    const stats = await fsPromises.stat(filePath);
    const cacheKey = `${filePath}:${stats.mtime.getTime()}`;
    const cached = fileAnalysisCache.get(cacheKey);

    if (cached) {
      return cached.data.exports;
    }

    if (stats.size > FILE_SIZE_LIMIT) {
      logger.warn(`File too large to analyze: ${filePath}`);
      return [];
    }

    const code = await fsPromises.readFile(filePath, 'utf-8');
    if (!code.trim()) {
      return [];
    }

    const exportedFunctions: string[] = [];
    try {
      const ast = parse(code, babelConfig);

      traverse(ast, {
        ExportNamedDeclaration(path) {
          if (path.node.declaration?.type === 'FunctionDeclaration') {
            const funcName = path.node.declaration.id?.name;
            if (funcName) exportedFunctions.push(funcName);
          }
        },
        ExportDefaultDeclaration(path) {
          if (path.node.declaration?.type === 'FunctionDeclaration') {
            const funcName = path.node.declaration.id?.name;
            if (funcName) exportedFunctions.push(funcName);
          }
        }
      });

      fileAnalysisCache.set(cacheKey, {
        timestamp: Date.now(),
        data: { exports: exportedFunctions, imports: [] }
      });

      return exportedFunctions;
    } catch (parseError) {
      logger.error(`Parse error in ${filePath}:`, parseError);
      return [];
    }
  } catch (error) {
    logger.error(`Error extracting functions from ${filePath}:`, error);
    return [];
  }
}

// Analyse des fichiers du projet
async function analyzeProjectFiles(projectPath: string, projectId: string): Promise<ProjectAnalysisResult> {
  const errors: Array<{ file: string; error: string }> = [];
  const processedFiles = new Set<string>();

  async function* findJsTsFiles(dir: string): AsyncGenerator<string> {
    const entries = await fsPromises.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        yield* findJsTsFiles(fullPath);
      } else if (entry.isFile() && /\.(js|ts|jsx|tsx)$/.test(entry.name)) {
        if (isValidFile(entry.name)) {
          yield fullPath;
        }
      }
    }
  }

  async function processBatch(files: string[]) {
    const nodes: ProjectNode[] = [];
    const edges: ProjectEdge[] = [];

    await Promise.all(files.map(async (filePath) => {
      try {
        if (processedFiles.has(filePath)) return;
        processedFiles.add(filePath);

        const stats = await fsPromises.stat(filePath);
        if (stats.size > FILE_SIZE_LIMIT) {
          throw new Error('File too large');
        }

        const content = await fsPromises.readFile(filePath, 'utf-8');
        if (!content.trim()) return;

        const exportedFunctions = await extractExportedFunctions(filePath);
        const relativeFilePath = path.relative(projectPath, filePath).replace(/\\/g, '/');
        
        const node: ProjectNode = {
          project: projectId,
          id: relativeFilePath,
          type: 'code',
          position: { x: Math.random() * 800, y: Math.random() * 600 },
          data: {
            label: path.basename(filePath),
            fileName: relativeFilePath,
            imports: [],
            code: content,
            exportedFunctions,
            lintErrors: []
          }
        };

        try {
          const ast = parse(content, babelConfig);
          traverse(ast, {
            ImportDeclaration(path) {
              const importSource = path.node.source.value;
              node.data.imports.push(importSource);

              const targetPath = resolveImportPath(projectPath, filePath, importSource);
              if (targetPath) {
                edges.push({
                  project: projectId,
                  id: `${relativeFilePath}_to_${targetPath}`,
                  source: relativeFilePath,
                  target: targetPath,
                  animated: false,
                  label: 'imports'
                });
              }
            }
          });
        } catch (parseError) {
          logger.error(`Parse error in ${filePath}:`, parseError);
        }

        nodes.push(node);
      } catch (error: any) {
        errors.push({ file: filePath, error: error.message });
      }
    }));

    if (nodes.length > 0) {
      await NodeModel.bulkWrite(
        nodes.map(node => ({
          updateOne: {
            filter: { project: node.project, id: node.id },
            update: { $set: node },
            upsert: true
          }
        }))
      );
    }

    if (edges.length > 0) {
      await EdgeModel.bulkWrite(
        edges.map(edge => ({
          updateOne: {
            filter: { project: edge.project, id: edge.id },
            update: { $set: edge },
            upsert: true
          }
        }))
      );
    }
  }

  const filesBatch: string[] = [];
  for await (const file of findJsTsFiles(projectPath)) {
    filesBatch.push(file);
    if (filesBatch.length >= CONCURRENT_LIMIT) {
      await processBatch([...filesBatch]);
      filesBatch.length = 0;
    }
  }

  if (filesBatch.length > 0) {
    await processBatch(filesBatch);
  }

  return {
    processedFiles: processedFiles.size,
    errors: errors.length > 0 ? errors : undefined
  };
}

// Git handlers
export const pullFromGit = async (req: Request, res: Response) => {
  const { repoUrl } = req.body;

  if (!repoUrl || typeof repoUrl !== 'string') {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'URL du dépôt Git invalide'
    });
  }

  const projectName = path.basename(repoUrl, '.git')
    .replace(/[^a-zA-Z0-9-_]/g, '_');
  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    const projectExists = await fsPromises.access(projectPath)
      .then(() => true)
      .catch(() => false);

    if (projectExists) {
      await git.cwd(projectPath);
      const status = await git.status();
      
      if (!status.isClean()) {
        throw new Error('Working directory is not clean');
      }
      
      await git.pull(['--ff-only', '--quiet']);
    } else {
      await git.clone(repoUrl, projectPath, [
        '--depth', '1',
        '--single-branch',
        '--quiet'
      ]);
    }

    const project = await Project.findOneAndUpdate(
      { name: projectName },
      { name: projectName },
      { upsert: true, new: true }
    );

    const shouldInstall = await checkNeedsDependencyInstall(projectPath);
    if (shouldInstall) {
      await installDependencies(projectPath);
    }

    const analysisResult = await analyzeProjectFiles(projectPath, project._id.toString());

    res.json({
      message: 'Projet importé avec succès',
      projectName,
      analysis: analysisResult
    });
  } catch (error) {
    handleGitError(error, res);
  }
};

export const commitChanges = async (req: Request, res: Response) => {
  const { projectName, commitMessage } = req.body;

  if (!projectName || !commitMessage?.trim()) {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'Nom du projet et message de commit requis'
    });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    const status = await git.status();

    if (status.isClean()) {
      return res.json({ message: 'Aucun changement à commiter' });
    }

    await git.add('.');
    await git.commit(commitMessage.trim(), {
      '--no-verify': null,
      '--quiet': null
    });

    res.json({ message: 'Changements commités avec succès' });
  } catch (error) {
    handleGitError(error, res);
  }
};

export const pushChanges = async (req: Request, res: Response) => {
  const { projectName } = req.body;

  if (!projectName) {
    return res.status(400).json({
      code: ErrorCode.VALIDATION_ERROR,
      message: 'Nom du projet requis'
    });
  }

  const projectPath = path.join(__dirname, '..', 'projects', projectName);

  try {
    await git.cwd(projectPath);
    await git.push(['--quiet', '--force-with-lease']);
    
    res.json({ message: 'Changements poussés avec succès' });
  } catch (error) {
    handleGitError(error, res);
  }
};

// Utility functions
function handleGitError(error: unknown, res: Response) {
  logger.error('Git error:', error);
  
  if (error instanceof GitError) {
    res.status(400).json({
      code: ErrorCode.GIT_ERROR,
      message: 'Erreur Git',
      details: error.message
    });
  } else {
    res.status(500).json({
      code: ErrorCode.GIT_ERROR,
      message: 'Erreur interne',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

async function checkNeedsDependencyInstall(projectPath: string): Promise<boolean> {
  const packageLockPath = path.join(projectPath, 'package-lock.json');
  const nodeModulesPath = path.join(projectPath, 'node_modules');
  
  return !(await fsPromises.access(packageLockPath).then(() => true).catch(() => false) &&
           await fsPromises.access(nodeModulesPath).then(() => true).catch(() => false));
}

async function installDependencies(projectPath: string): Promise<void> {
  try {
    await execAsync('npm install --quiet', {
      cwd: projectPath,
      timeout: 300000, // 5 minutes
      maxBuffer: 10 * 1024 * 1024 // 10MB
    });
  } catch (error) {
    throw new Error(`Erreur d'installation des dépendances: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

function resolveImportPath(projectPath: string, currentFile: string, importPath: string): string | null {
  try {
    if (importPath.startsWith('.')) {
      const absolutePath = path.resolve(path.dirname(currentFile), importPath);
      return path.relative(projectPath, absolutePath).replace(/\\/g, '/');
    }
    return null;
  } catch {
    return null;
  }
}

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/graphController.ts

import Redis from 'ioredis';
import { QueuedOperation } from '../types/queue';

export class RedisService {
  private client: Redis;
  private static instance: RedisService;
  
  private constructor() {
    this.client = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: Number(process.env.REDIS_PORT) || 6379,
      maxRetriesPerRequest: null,
    });
  }

  static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  async addToQueue(operation: QueuedOperation): Promise<void> {
    await this.client.lpush('graph_operations_queue', JSON.stringify(operation));
  }

  async getFromQueue(): Promise<QueuedOperation | null> {
    const data = await this.client.rpop('graph_operations_queue');
    return data ? JSON.parse(data) : null;
  }

  async setOperationStatus(operationId: string, status: QueuedOperation['status'], result?: any): Promise<void> {
    await this.client.hset(
      `operation:${operationId}`,
      'status', status,
      'result', JSON.stringify(result || {})
    );
    await this.client.expire(`operation:${operationId}`, 3600); // Expire après 1 heure
  }

  async getOperationStatus(operationId: string): Promise<{ status: string; result: any } | null> {
    const data = await this.client.hgetall(`operation:${operationId}`);
    return data ? {
      status: data.status,
      result: JSON.parse(data.result || '{}')
    } : null;
  }

  async checkDuplicate(requestHash: string): Promise<string | null> {
    return this.client.get(`request:${requestHash}`);
  }

  async setDuplicate(requestHash: string, operationId: string): Promise<void> {
    await this.client.set(`request:${requestHash}`, operationId, 'EX', 3600);
  }
}

// 3. Contrôleur mis à jour (controllers/graphController.ts)
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { createHash } from 'crypto';
import { RedisService } from '../services/redis';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import path from 'path';
import fs from 'fs/promises';
import { QueuedOperation } from '../types/queue';

const redisService = RedisService.getInstance();

function generateRequestHash(data: any): string {
  return createHash('md5').update(JSON.stringify(data)).digest('hex');
}

export const updateGraph = async (req: Request, res: Response) => {
  const { project, nodes, edges } = req.body;

  if (!project || !nodes || !edges) {
    return res.status(400).json({ message: 'Project, nodes, and edges are required.' });
  }

  try {
    // Générer un hash pour détecter les doublons
    const requestHash = generateRequestHash({ project, nodes, edges });
    
    // Vérifier les doublons
    const existingOperationId = await redisService.checkDuplicate(requestHash);
    if (existingOperationId) {
      return res.json({ 
        message: 'Operation already in progress',
        operationId: existingOperationId
      });
    }

    const operationId = uuidv4();
    const operation: QueuedOperation = {
      id: operationId,
      type: 'updateGraph',
      data: { project, nodes, edges },
      timestamp: Date.now(),
      requestHash,
      status: 'pending'
    };

    await redisService.addToQueue(operation);
    await redisService.setDuplicate(requestHash, operationId);
    await redisService.setOperationStatus(operationId, 'pending');

    res.json({ 
      message: 'Update queued successfully',
      operationId
    });
  } catch (error) {
    console.error('Error queueing graph update:', error);
    res.status(500).json({ message: 'Error queueing update', error: error.message });
  }
};

export const checkOperationStatus = async (req: Request, res: Response) => {
  const { operationId } = req.params;

  try {
    const status = await redisService.getOperationStatus(operationId);
    if (!status) {
      return res.status(404).json({ message: 'Operation not found' });
    }
    res.json(status);
  } catch (error) {
    console.error('Error checking operation status:', error);
    res.status(500).json({ message: 'Error checking status' });
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/importController.ts

import { Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import logger from '../utils/logger';

/**
 * Configuration de Multer pour stocker les fichiers uploadés dans un dossier temporaire
 */
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

/**
 * Type pour les données du fichier de projet importé
 */
interface ImportedProject {
  projectName: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      fileName: string;
      imports: string[];
      code: string;
      exportedFunctions: string[];
      lintErrors?: any[];
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    animated?: boolean;
    label?: string;
  }>;
}

/**
 * Importe un projet depuis un fichier JSON
 * @param req - Requête Express avec le fichier uploadé
 * @param res - Réponse Express
 */
export const importProject = [
  upload.single('projectFile'),
  async (req: Request, res: Response) => {
    // Validation des données
    if (!req.file) {
      logger.error('No file uploaded for project import.');
      return res.status(400).json({ message: 'Aucun fichier uploadé.' });
    }

    try {
      const projectData: ImportedProject = JSON.parse(req.file.buffer.toString('utf-8'));

      // Valider la structure du fichier
      const schema = Joi.object({
        projectName: Joi.string().alphanum().min(3).max(30).required(),
        nodes: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            type: Joi.string().required(),
            position: Joi.object({
              x: Joi.number().required(),
              y: Joi.number().required(),
            }).required(),
            data: Joi.object({
              label: Joi.string().required(),
              fileName: Joi.string().required(),
              imports: Joi.array().items(Joi.string()).required(),
              code: Joi.string().required(),
              exportedFunctions: Joi.array().items(Joi.string()).required(),
              lintErrors: Joi.array().items(Joi.any()).optional(),
            }).required(),
          })
        ).required(),
        edges: Joi.array().items(
          Joi.object({
            id: Joi.string().required(),
            source: Joi.string().required(),
            target: Joi.string().required(),
            animated: Joi.boolean().optional(),
            label: Joi.string().optional(),
          })
        ).required(),
      });

      const { error } = schema.validate(projectData);
      if (error) {
        logger.error(`Validation error during project import: ${error.details[0].message}`);
        return res.status(400).json({ message: error.details[0].message });
      }

      const { projectName, nodes, edges } = projectData;

      // Vérifier si le projet existe déjà
      const existingProject = await Project.findOne({ name: projectName });
      if (existingProject) {
        logger.warn(`Import project failed: Project "${projectName}" already exists.`);
        return res.status(400).json({ message: 'Le projet existe déjà.' });
      }

      // Créer le dossier du projet
      const projectPath = path.join(__dirname, '..', 'projects', projectName);
      await fs.mkdir(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);

      // Créer les fichiers des nœuds
      for (const node of nodes) {
        const filePath = path.join(projectPath, node.data.fileName);
        await fs.writeFile(filePath, node.data.code);
        logger.info(`File created for node "${node.id}" at: ${filePath}`);
      }

      // Initialiser un package.json
      await fs.writeFile(path.join(projectPath, 'package.json'), JSON.stringify({
        name: projectName,
        version: "1.0.0",
        main: "index.js",
        scripts: {
          start: "node index.js"
        },
        dependencies: {}
      }, null, 2));
      logger.info(`package.json created at: ${path.join(projectPath, 'package.json')}`);

      // Enregistrer le projet dans la base de données
      const newProject = new Project({
        name: projectName,
      });

      const savedProject = await newProject.save();
      logger.info(`Project "${projectName}" saved to database.`);

      // Enregistrer les nœuds dans la base de données
      for (const node of nodes) {
        const newNode = new NodeModel({
          project: savedProject._id,
          id: node.id,
          type: node.type,
          position: node.position,
          data: node.data,
        });
        await newNode.save();
        logger.info(`Node "${node.id}" saved to database.`);
      }

      // Vous pouvez également enregistrer les arêtes si vous avez un modèle pour les arêtes

      res.status(201).json({ message: 'Projet importé avec succès.', project: savedProject });
    } catch (error: any) {
      logger.error(`Error during project import: ${error.message}`);
      res.status(500).json({ message: 'Erreur lors de l\'importation du projet.', error: error.message });
    }
  }
];


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/nodeController.ts

import { Request, Response } from 'express';
import { getFilePath, writeFile } from '../utils/fileUtils';
import NodeModel from '../models/Node';

interface NodeData {
  label: string;
  fileName: string;
  code: string;
  [key: string]: any;
}

interface UpdateNodeRequest {
  project: string;
  nodeId: string;
  nodeData: NodeData;
}

// Validation des données d'entrée
const validateInput = (data: Partial<UpdateNodeRequest>): string | null => {
  const { project, nodeId, nodeData } = data;
  
  if (!project || !nodeId || !nodeData) {
    return 'Project, nodeId, and nodeData are required.';
  }

  const requiredFields = ['label', 'fileName', 'code'];
  const missingField = requiredFields.find(field => !nodeData[field]);
  
  if (missingField) {
    return `Field '${missingField}' is required in nodeData.`;
  }

  return null;
};

// Mise à jour du node dans la base de données
const updateNodeInDb = async (
  project: string, 
  nodeId: string, 
  nodeData: NodeData
) => {
  const updatedNode = await NodeModel.findOneAndUpdate(
    { project, id: nodeId },
    { $set: { data: nodeData } },
    { new: true, runValidators: true }
  );

  if (!updatedNode) {
    throw new Error('Node not found.');
  }

  return updatedNode;
};

// Écriture du code dans le système de fichiers
const writeCodeToFile = async (
  project: string, 
  fileName: string, 
  code: string
): Promise<void> => {
  const filePath = getFilePath(project, fileName);
  await writeFile(filePath, code);
};

// Controller principal
export const updateNode = async (req: Request, res: Response): Promise<Response> => {
  const { project, nodeId, nodeData } = req.body;

  try {
    // Validation
    const validationError = validateInput(req.body);
    if (validationError) {
      return res.status(400).json({ message: validationError });
    }

    // Mise à jour en base de données
    const updatedNode = await updateNodeInDb(project, nodeId, nodeData);

    // Écriture du fichier
    await writeCodeToFile(project, nodeData.fileName, nodeData.code);

    return res.json({
      message: 'Node updated successfully.',
      node: updatedNode
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    const statusCode = errorMessage === 'Node not found.' ? 404 : 500;

    return res.status(statusCode).json({
      message: 'Error updating node or writing file.',
      error: errorMessage
    });
  }
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/controllers/projectController.ts

import { Request, Response } from 'express';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs';
import Joi from 'joi';
import Project from '../models/Project';
import NodeModel from '../models/Node';
import Edge from '../models/Edge';
import simpleGit, { SimpleGit } from 'simple-git';
import logger from '../utils/logger';
import { analyzeFile } from '../utils/fileAnalyzer';

export async function analyzeProject(req: Request, res: Response) {
  const { projectId } = req.params;
  const projectPath = path.join(__dirname, '..', 'projects', projectId);

  try {
    // Vérifier que le projet existe
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ 
        message: 'Projet non trouvé',
        error: 'Project not found' 
      });
    }

    // Récupérer tous les fichiers .js et .ts
    const files = await getAllJsTsFiles(projectPath);
    
    // Analyser chaque fichier
    const analysisPromises = files.map(file => 
      analyzeFile(file, projectId, projectPath)
    );

    const results = await Promise.all(analysisPromises);

    // Compiler les résultats
    const nodes = results.flatMap(result => result.nodes);
    
    res.json({
      message: 'Analyse du projet terminée avec succès',
      projectId,
      nodesCount: nodes.length
    });

  } catch (error: any) {
    logger.error(`Erreur lors de l'analyse du projet ${projectId}: ${error.message}`);
    res.status(500).json({ 
      message: 'Erreur lors de l\'analyse du projet',
      error: error.message 
    });
  }
}

async function getAllJsTsFiles(dirPath: string): Promise<string[]> {
  const files: string[] = [];
  async function scan(currentPath: string) {
    const entries = await fs.promises.readdir(currentPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(currentPath, entry.name);
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        await scan(fullPath);
      } else if (
        entry.isFile() && 
        (entry.name.endsWith('.js') || entry.name.endsWith('.ts'))
      ) {
        files.push(fullPath);
      }
    }
  }

  await scan(dirPath);
  return files;
}




// Initialiser simple-git avec l'option de journalisation
const git: SimpleGit = simpleGit();

/**
 * Crée un nouveau projet.
 * @param req - Requête Express contenant projectCode, projectName et gitRepo dans le corps.
 * @param res - Réponse Express.
 */
export const createProject = async (req: Request, res: Response) => {
  const schema = Joi.object({
    projectCode: Joi.string().required(),
    projectName: Joi.string().alphanum().min(3).max(30).required(),
    gitRepo: Joi.string().uri().optional(), // Ajouter un champ pour l'URL du dépôt Git
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { projectCode, projectName, gitRepo } = req.body;

  try {
    // Vérifier si le projet existe déjà
    const existingProject = await Project.findOne({ name: projectName });
    if (existingProject) {
      logger.warn(`Project creation failed: Project "${projectName}" already exists.`);
      return res.status(400).json({ message: 'Le projet existe déjà.' });
    }

    // Créer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
      logger.info(`Project directory created at: ${projectPath}`);
    }

    // Initialiser Git si un dépôt Git est fourni
    if (gitRepo) {
      try {
        await git.clone(gitRepo, projectPath);
        logger.info(`Git repository cloned from ${gitRepo} into ${projectPath}`);
      } catch (gitError: any) {
        logger.error(`Failed to clone Git repository: ${gitError.message}`);
        return res.status(500).json({ message: 'Erreur lors du clonage du dépôt Git.', error: gitError.message });
      }
    }

    // Créer le fichier principal (par exemple, index.ts)
    const mainFilePath = path.join(projectPath, 'index.ts');
    fs.writeFileSync(mainFilePath, projectCode);
    logger.info(`Main file created at: ${mainFilePath}`);

    // Initialiser un package.json
    exec('npm init -y', { cwd: projectPath }, async (err, stdout, stderr) => {
      if (err) {
        logger.error(`Error initializing npm: ${err.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'initialisation du projet.' });
      }

      logger.info(`npm initialized for project "${projectName}".`);

      try {
        // Enregistrer le projet dans la base de données
        const newProject = new Project({
          name: projectName,
        });

        const savedProject = await newProject.save();
        logger.info(`Project "${projectName}" saved to database.`);

        res.status(201).json({ message: 'Projet créé avec succès.', project: savedProject });
      } catch (saveError: any) {
        logger.error(`Error saving project to database: ${saveError.message}`);
        res.status(500).json({ message: 'Erreur lors de la création du projet.', error: saveError.message });
      }
    });

  } catch (error: any) {
    logger.error(`Error creating project: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la création du projet.', error: error.message });
  }
};

/**
 * Récupère la liste des projets.
 * @param req - Requête Express.
 * @param res - Réponse Express.
 */
export const getProjects = async (req: Request, res: Response) => {
  try {
    const projects = await Project.find().select('name createdAt');
    logger.info('Fetched list of projects.');
    res.json(projects);
  } catch (error: any) {
    logger.error(`Error fetching projects: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la récupération des projets.', error: error.message });
  }
};

/**
 * Installe un package npm dans un projet spécifique.
 * @param req - Requête Express contenant project et packageName dans le corps.
 * @param res - Réponse Express.
 */
export const installPackage = async (req: Request, res: Response) => {
  const schema = Joi.object({
    project: Joi.string().required(),
    packageName: Joi.string().required(),
  });

  const { error } = schema.validate(req.body);
  if (error) {
    logger.error(`Validation error: ${error.details[0].message}`);
    return res.status(400).json({ message: error.details[0].message });
  }

  const { project, packageName } = req.body;

  try {
    // Trouver le projet dans la base de données
    const existingProject = await Project.findOne({ name: project });
    if (!existingProject) {
      logger.warn(`Install package failed: Project "${project}" not found.`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    const projectPath = path.join(__dirname, '..', 'projects', project);

    // Vérifier si le dossier du projet existe
    if (!fs.existsSync(projectPath)) {
      logger.error(`Project directory does not exist: ${projectPath}`);
      return res.status(400).json({ message: 'Le dossier du projet n\'existe pas.' });
    }

    logger.info(`Installing package "${packageName}" in project "${project}".`);

    // Exécuter la commande npm install
    exec(`npm install ${packageName}`, { cwd: projectPath }, (error, stdout, stderr) => {
      if (error) {
        logger.error(`Error installing package: ${error.message}`);
        return res.status(500).json({ message: 'Erreur lors de l\'installation du package.', stderr: stderr });
      }

      if (stderr) {
        logger.warn(`npm stderr: ${stderr}`);
        // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
      }

      logger.info(`npm stdout: ${stdout}`);
      res.json({ message: `Package "${packageName}" installé avec succès.`, stdout, stderr });
    });
  } catch (error: any) {
    logger.error(`Error installing package: ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de l\'installation du package.', error: error.message });
  }
};

export const deleteProject = async (req: Request, res: Response) => {
  const { projectName } = req.params;
  logger.info(`Attempting to delete project: ${projectName}`);

  try {
    // Supprimer le projet de la base de données
    const project = await Project.findOneAndDelete({ name: projectName });
    if (!project) {
      logger.warn(`Project not found: ${projectName}`);
      return res.status(404).json({ message: 'Projet non trouvé.' });
    }

    logger.info(`Project "${projectName}" deleted from database.`);

    // Supprimer tous les nœuds et arêtes associés
    await NodeModel.deleteMany({ project: project._id });
    await Edge.deleteMany({ project: project._id });
    logger.info(`Associated nodes and edges deleted for project "${projectName}".`);

    // Supprimer le dossier du projet
    const projectPath = path.join(__dirname, '..', 'projects', projectName);
    logger.info(`Project path to delete: ${projectPath}`);

    await fs.promises.rm(projectPath, { recursive: true, force: true });
    logger.info(`Project directory "${projectPath}" deleted successfully.`);

    res.json({ message: 'Projet supprimé avec succès.' });
  } catch (error: any) {
    logger.error(`Error deleting project "${projectName}": ${error.message}`);
    res.status(500).json({ message: 'Erreur lors de la suppression du projet.', error: error.message });
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/middleware/auth.ts

// backend/src/middleware/auth.ts

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'; // Assurez-vous de définir JWT_SECRET dans votre fichier .env

interface JwtPayload {
  userId: string;
  // Ajoutez d'autres propriétés si nécessaire
}

// Extension de l'interface Request pour inclure user
declare module 'express-serve-static-core' {
  interface Request {
    user?: JwtPayload;
  }
}

export const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (authHeader) {
    // Le format attendu est "Bearer <token>"
    const token = authHeader.split(' ')[1];

    jwt.verify(token, SECRET_KEY, (err, payload) => {
      if (err) {
        logger.warn('Invalid JWT token');
        return res.sendStatus(403); // Forbidden
      }

      // Vous pouvez ajouter le payload à la requête pour une utilisation future
      req.user = payload as JwtPayload;
      next();
    });
  } else {
    logger.warn('No Authorization header provided');
    res.sendStatus(401); // Unauthorized
  }
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/middleware/errorHandler.ts

import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  logger.error(`Unhandled Error: ${err.message}`);
  res.status(500).json({ message: 'Internal Server Error', error: err.message });
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/models/Edge.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IEdge extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  source: string;
  target: string;
  animated: boolean;
  label: string;
}

const EdgeSchema: Schema = new Schema({
  project: { 
    type: Schema.Types.ObjectId, 
    ref: 'Project', 
    required: true 
  },
  id: { 
    type: String, 
    required: true 
  },
  source: { 
    type: String, 
    required: true 
  },
  target: { 
    type: String, 
    required: true 
  },
  animated: { 
    type: Boolean, 
    default: false 
  },
  label: { 
    type: String, 
    default: 'connects to' 
  }
});

export default mongoose.model<IEdge>('Edge', EdgeSchema);

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/models/Node.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface INodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
  lintErrors?: any[];
}

export interface INode extends Document {
  project: mongoose.Types.ObjectId;
  id: string;
  type: string;
  position: {
    x: number;
    y: number;
  };
  data: INodeData;
}

const NodeSchema: Schema = new Schema({
  project: { 
    type: String, 
    required: true 
  },
  id: { 
    type: String, 
    required: true 
  },
  type: { 
    type: String, 
    required: true 
  },
  position: {
    x: { type: Number, required: true, default: 0 },
    y: { type: Number, required: true, default: 0 },
  },
  data: {
    label: { type: String, required: true },
    fileName: { type: String, required: true },
    imports: { type: [String], default: [] },
    code: { type: String, required: true },
    exportedFunctions: { type: [String], default: [] },
    lintErrors: { type: [Schema.Types.Mixed], default: [] },
  },
});

export default mongoose.model<INode>('Node', NodeSchema);

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/models/Project.ts

import mongoose, { Document, Schema } from 'mongoose';

export interface IProject extends Document {
  name: string;
  createdAt: Date;
}

const ProjectSchema: Schema = new Schema({
  name: { 
    type: String, 
    required: true,
    unique: true 
  },
  createdAt: { 
    type: Date, 
    default: Date.now 
  }
});

export default mongoose.model<IProject>('Project', ProjectSchema);

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/models/User.ts

import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends Document {
  username: string;
  password: string;
  comparePassword: (candidatePassword: string) => Promise<boolean>;
}

const UserSchema: Schema = new Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

// Middleware pour hacher le mot de passe avant de sauvegarder
UserSchema.pre<IUser>('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(this.password, salt);
    this.password = hashed;
    next();
  } catch (err) {
    next(err as any);
  }
});

// Méthode pour comparer les mots de passe
UserSchema.methods.comparePassword = function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/authRoutes.ts

// backend/src/routes/authRoutes.ts

import express from 'express';
import { register, login } from '../controllers/authController';

const router = express.Router();

/**
 * @route POST /auth/register
 * @desc Inscription d'un nouvel utilisateur
 * @access Public
 */
router.post('/register', register);

/**
 * @route POST /auth/login
 * @desc Connexion d'un utilisateur existant
 * @access Public
 */
router.post('/login', login);

export default router;


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/devServerRoutes.ts

// backend/src/routes/devServerRoutes.ts

import express from 'express';
import { startDevServer, stopDevServer } from '../controllers/devServerController';

const router = express.Router();

/**
 * @route POST /dev-server/start
 * @desc Démarre le serveur de développement pour un projet donné.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/start', startDevServer);

/**
 * @route POST /dev-server/stop
 * @desc Arrête le serveur de développement en cours.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/stop', stopDevServer);

export default router;


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/executeRoutes.ts

import express from 'express';
import { executeNode } from '../controllers/executeController';

const router = express.Router();

router.post('/', executeNode);

export default router;


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/fileRoutes.ts

import express from 'express';
import { updateFile, getAccessibleFunctions } from '../controllers/fileController';

const router = express.Router();

router.post('/', updateFile);
router.get('/accessible-functions', getAccessibleFunctions);

export default router;

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/gitRoutes.ts

import express from 'express';
import { pullFromGit, commitChanges, pushChanges } from '../controllers/gitController';

const router = express.Router();

router.post('/pull', pullFromGit);
router.post('/commit', commitChanges);
router.post('/push', pushChanges);

export default router;

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/graphRoutes.ts

// backend/routes/graphRoutes.ts

import express from 'express';
import { getProjectGraph, updateGraph, deleteNode, cloneNode } from '../controllers/graphController';

const router = express.Router();

router.get('/', getProjectGraph);
router.post('/update-graph', updateGraph);
router.post('/delete-node', deleteNode);
router.post('/clone-node', cloneNode);

export default router;

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/importRoutes.ts

import express from 'express';
import { importProject } from '../controllers/importController';
import { authenticateJWT } from '../middleware/auth'; // Si vous avez mis en place l'authentification

const router = express.Router();

/**
 * @route POST /import
 * @desc Importe un projet depuis un fichier JSON
 * @access Protected
 */
router.post('/import', authenticateJWT, importProject);

export default router;


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/routes/projectRoutes.ts

import express from 'express';
import { getProjects, createProject, installPackage, deleteProject } from '../controllers/projectController';

const router = express.Router();

router.get('/', getProjects);
router.post('/create-project', createProject);
router.post('/install-package', installPackage);
router.delete('/:projectName', deleteProject);

export default router;


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/server.ts

// backend/src/server.ts

import express from 'express';
import cors from 'cors';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import projectRoutes from './routes/projectRoutes';
import graphRoutes from './routes/graphRoutes';
import fileRoutes from './routes/fileRoutes';
import executeRoutes from './routes/executeRoutes';
import devServerRoutes from './routes/devServerRoutes';
import gitRoutes from './routes/gitRoutes'; // Si vous avez des routes Git

import { errorHandler } from './middleware/errorHandler'; // Middleware de gestion des erreurs
import logger from './utils/logger'; // Importer le logger

// Documentation de l'API (par exemple Swagger)
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/projects', projectRoutes);
app.use('/project-graph', graphRoutes);
app.use('/update-file', fileRoutes);
app.use('/execute', executeRoutes);
app.use('/dev-server', devServerRoutes);
app.use('/git', gitRoutes); // Si vous avez des routes Git

// Configuration Swagger
const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Low-Code App API',
      version: '1.0.0',
    },
  },
  apis: ['./src/routes/*.ts'], // Chemin vers vos fichiers de routes
};

const specs = swaggerJsdoc(options);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

// Middleware de gestion des erreurs (doit être placé après toutes les routes)
app.use(errorHandler);

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/low-code-app')
  .then(() => {
    logger.info('Connected to MongoDB');
    // Démarrer le serveur seulement après la connexion à MongoDB
    app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => {
    logger.error(`MongoDB connection error: ${err.message}`);
  });


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/types.ts

// backend/src/types.ts

export interface NodePosition {
  x: number;
  y: number;
}

export interface NodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
}

export interface Node {
  id: string;
  type: string;
  position: NodePosition;
  data: NodeData;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  label?: string;
}

export interface ProjectGraph {
  nodes: Node[];
  edges: Edge[];
}

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils/compileNodes.ts

import { INode } from '../models/Node';

export function compileNodes(nodes: INode[], entryFile: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Ajouter les imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Ajouter le code du node dans une closure
    compiledCode += `
(function(module, exports) {
  ${node.data.code}
})((module = { exports: {} }, exports = module.exports));
`;
    // Exporter les fonctions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `module.exports.${func} = ${func};\n`;
    });
  }

  // Commencer la compilation à partir du fichier d'entrée
  compileNode(entryFile);

  return compiledCode;
}


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils/executeCode.ts

import { exec } from 'child_process';
import path from 'path';

export const executeCode = (filePath: string, callback: (error: Error | null, result: { stdout: string; stderr: string } | null) => void) => {
  exec(`node ${filePath}`, (error, stdout, stderr) => {
    if (error) {
      console.error(`Execution error: ${error.message}`);
      return callback(error, null);
    }

    if (stderr) {
      console.error(`stderr: ${stderr}`);
      // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
    }

    console.log(`stdout: ${stdout}`);
    callback(null, { stdout, stderr });
  });
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils/fileAnalyzer.ts

import fs from 'fs/promises';
import path from 'path';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import NodeModel, { INode } from '../models/Node';
import logger from '../utils/logger';

export interface FileAnalysisResult {
  nodes: INode[];
  imports: string[];
  exportedFunctions: string[];
}

export async function analyzeFile(
  filePath: string,
  projectId: string,
  projectPath: string
): Promise<FileAnalysisResult> {
  try {
    // Lire le contenu du fichier
    const content = await fs.readFile(filePath, 'utf-8');
    if (!content) {
      throw new Error(`Fichier vide: ${filePath}`);
    }

    // Analyser le code avec Babel
    const ast = parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    // Extraire les imports et exports
    const imports: string[] = [];
    const exportedFunctions: string[] = [];

    traverse(ast, {
      ImportDeclaration(path) {
        const source = path.node.source.value;
        imports.push(source);
      },
      ExportNamedDeclaration(path) {
        const { declaration } = path.node;
        if (declaration && declaration.type === 'FunctionDeclaration') {
          const funcName = declaration.id?.name;
          if (funcName) {
            exportedFunctions.push(funcName);
          }
        }
      },
    });

    // Créer le nœud
    const relativeFilePath = path.relative(projectPath, filePath);
    const nodeId = relativeFilePath.replace(/\\/g, '/');

    const nodeData = {
      project: projectId,
      id: nodeId,
      type: 'code',
      position: { 
        x: Math.random() * 500, 
        y: Math.random() * 500 
      },
      data: {
        label: path.basename(filePath),
        fileName: relativeFilePath,
        imports: imports,
        code: content,
        exportedFunctions: exportedFunctions,
        lintErrors: []
      }
    };

    // Sauvegarder le nœud
    const node = await NodeModel.findOneAndUpdate(
      { project: projectId, id: nodeId },
      nodeData,
      { upsert: true, new: true, runValidators: true }
    );

    if (!node) {
      throw new Error(`Échec de la création/mise à jour du nœud pour ${nodeId}`);
    }

    logger.info(`Nœud créé/mis à jour avec succès pour ${nodeId}`);

    return {
      nodes: [node],
      imports,
      exportedFunctions
    };

  } catch (error: any) {
    logger.error(`Erreur lors de l'analyse du fichier ${filePath}: ${error.message}`);
    throw error;
  }
}

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils/fileUtils.ts


import fs from 'fs/promises';
import path from 'path';
import logger from './logger';
import mkdirp from 'mkdirp'; // Ajoutez cette dépendance si ce n'est pas déjà fait

/**
 * Résout le chemin du fichier pour un projet donné.
 * @param project - Nom du projet.
 * @param fileName - Nom du fichier.
 * @returns Chemin complet du fichier.
 */
export async function getFilePath(project: string, fileName: string): Promise<string> {
  // Le dossier de base des projets
  const projectsBasePath = path.join(__dirname, '..', 'projects');
  const projectPath = path.join(projectsBasePath, project);
  
  // Construire le chemin complet du fichier
  const fullPath = path.join(projectPath, fileName);
  
  // S'assurer que le dossier parent existe
  const dirPath = path.dirname(fullPath);
  await mkdirp(dirPath);
  
  logger.info(`Built file path: ${fullPath}`);
  return fullPath;
}

/**
 * Écrit du contenu dans un fichier.
 * @param filePath - Chemin du fichier à écrire.
 * @param content - Contenu à écrire dans le fichier.
 */
export async function writeFile(filePath: string, content: string): Promise<void> {
  logger.info(`Attempting to write file: ${filePath}`);
  try {
    // S'assurer que le dossier parent existe
    const dirPath = path.dirname(filePath);
    await mkdirp(dirPath);
    
    // Écrire le fichier
    await fs.writeFile(filePath, content);
    logger.info(`File successfully written at ${filePath}`);
  } catch (error) {
    logger.error(`Error writing file at ${filePath}: ${(error as Error).message}`);
    throw error;
  }
}

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils/logger.ts

import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

export default logger;

---------
/// my-low-code-app/backend/src/projects/my-low-code/backend/src/utils.ts

import { Node, Edge } from './types';

/**
 * Function to sanitize variable names.
 * Replace all invalid characters with underscores.
 * @param name Variable name to sanitize.
 * @returns Sanitized variable name.
 */
function sanitizeVariableName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

export function compileNodes(nodes: Node[], entryNodeId: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.error(`Node with id ${nodeId} not found`);
      return;
    }

    // Add imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Add node code within a closure
    const sanitizedFileName = sanitizeVariableName(node.data.fileName);
    compiledCode += `
const ${sanitizedFileName} = (function() {
  const module = { exports: {} };
  const exports = module.exports;
  ${node.data.code}
  return module.exports;
})();
`;

    // Export functions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `if (typeof ${sanitizedFileName}.${func} === 'function') {
  globalThis.${func} = ${sanitizedFileName}.${func};
}\n`;
    });
  }

  // Start compilation from the entry node
  compileNode(entryNodeId);

  return compiledCode;
}


 my-low-code-app/frontend/src/App.tsx

// frontend/src/App.tsx

import React from 'react';
import { Box } from '@chakra-ui/react';
import { ReactFlowProvider } from 'reactflow';
import { Sidebar } from './components/Sidebar';
import { GraphCanvas } from './components/GraphCanvas';
import { Console } from './components/Console';
import { Modals } from './components/Modals';
import { ProjectStructure } from './components/ProjectStructure';
import { AlertProvider } from './contexts/AlertContext';
import { ProjectProvider } from './contexts/ProjectContext';
import { GraphProvider } from './contexts/GraphContext';
import ErrorBoundary from './components/ErrorBoundary';
import { ModalProvider } from './contexts/ModalContext';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <AlertProvider>
        <ProjectProvider>
          <GraphProvider>
            <ModalProvider>
              <ReactFlowProvider>
                <Box display="flex" height="100vh">
                  <Sidebar />
                  <GraphCanvas />
                  <Box display="flex" flexDirection="column" width="40%">
                    <ProjectStructure />
                    <Console />
                  </Box>
                  <Modals />
                </Box>
              </ReactFlowProvider>
            </ModalProvider>
          </GraphProvider>
        </ProjectProvider>
      </AlertProvider>
    </ErrorBoundary>
  );
};

export default App;

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/App.tsx

// frontend/src/App.tsx

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ChakraProvider } from '@chakra-ui/react';
import { AuthProvider } from './contexts/AuthContext';
import { AlertProvider } from './contexts/AlertContext';
import { ProjectProvider } from './contexts/ProjectContext';
import { GraphProvider } from './contexts/GraphContext';
import { CombinedProvider } from './contexts/CombinedContext';
import { ModalProvider } from './contexts/ModalContext';
import { ProtectedRoute } from './components/ProtectedRoute';
import { LoginPage } from './pages/LoginPage';
import { RegisterPage } from './pages/RegisterPage';
import { MainApp } from './components/MainApp';
import { Header } from './components/Header';
import { ReactFlowProvider } from 'reactflow';
import ErrorBoundary from './components/ErrorBoundary';

const App: React.FC = () => {
  return (
    <ChakraProvider>
      <AlertProvider>
        <AuthProvider>
          <ProjectProvider> {/* ProjectProvider enveloppe GraphProvider */}
            <GraphProvider> {/* GraphProvider dépend de ProjectProvider */}
              <CombinedProvider> {/* CombinedProvider dépend de GraphProvider */}
                <ErrorBoundary>
                  <ModalProvider>
                    <ReactFlowProvider>
                      <Router>
                        <Header />
                        <Routes>
                          <Route path="/login" element={<LoginPage />} />
                          <Route path="/register" element={<RegisterPage />} />
                          <Route
                            path="/"
                            element={
                              <ProtectedRoute>
                                <MainApp />
                              </ProtectedRoute>
                            }
                          />
                          <Route path="*" element={<Navigate to="/" replace />} />
                        </Routes>
                      </Router>
                    </ReactFlowProvider>
                  </ModalProvider>
                </ErrorBoundary>
              </CombinedProvider>
            </GraphProvider>
          </ProjectProvider>
        </AuthProvider>
      </AlertProvider>
    </ChakraProvider>
  );
};

export default App;


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/axiosInstance.ts

// frontend/src/axiosInstance.ts

import axios from 'axios';

const axiosInstance = axios.create({
  baseURL: 'http://localhost:3000', // Ajustez selon votre configuration
  headers: {
    'Content-Type': 'application/json',
  },
});

axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token && config.headers) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    // Vous pouvez ajouter une logique ici pour gérer les erreurs globales
    return Promise.reject(error);
  }
);

export default axiosInstance;

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/CodeNode.tsx

// frontend/src/components/CodeNode.tsx

import React, { useState, useCallback, useEffect } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Box, Button, Input, VStack, HStack, Text } from '@chakra-ui/react';
import MonacoEditor from '@monaco-editor/react';
import Select from 'react-select';
import { useGraph } from '../contexts/GraphContext';
import axiosInstance from '../axiosInstance'; // Assurez-vous que ce chemin est correct
import { useProject } from '../contexts/ProjectContext';
import { useAlert } from '../contexts/AlertContext';
import { ResizableBox } from 'react-resizable';
import 'react-resizable/css/styles.css';

const CodeNode: React.FC<NodeProps> = ({ id, data }) => {
  const [code, setCode] = useState(data.code || '');
  const [fileName, setFileName] = useState(data.fileName || '');
  const [imports, setImports] = useState<string[]>(data.imports || []);
  const [availableImports, setAvailableImports] = useState<{ value: string; label: string }[]>([]);
  const [width, setWidth] = useState<number>(300);
  const [height, setHeight] = useState<number>(400);
  const { updateGraph, deleteNode, cloneNode, nodes, edges } = useGraph();
  const { selectedProject } = useProject();
  const { showAlert } = useAlert();

  useEffect(() => {
    axiosInstance
      .get('/accessible-functions', {
        params: { project: selectedProject, nodeId: id },
      })
      .then((response) => {
        const options = response.data.accessibleFunctions.map((func: string) => ({
          value: func,
          label: func,
        }));
        setAvailableImports(options);
      })
      .catch((error) => {
        console.error('Failed to fetch accessible functions:', error);
        showAlert('Échec de la récupération des fonctions accessibles.', 'error');
      });
  }, [id, selectedProject, showAlert]);

  const handleImportChange = (selectedOptions: any) => {
    const selectedImports = selectedOptions ? selectedOptions.map((option: any) => option.value) : [];
    setImports(selectedImports);
  };

  const handleResize = (event: any, { size }: { size: { width: number; height: number } }) => {
    setWidth(size.width);
    setHeight(size.height);
  };

  const handleSave = useCallback(async () => {
    const updatedNodes = nodes.map((node) =>
      node.id === id
        ? { ...node, data: { ...node.data, code, fileName, imports }, position: { ...node.position }, width, height }
        : node
    );

    try {
      await updateGraph(updatedNodes, edges);
      showAlert('Fichier sauvegardé avec succès.', 'success');
    } catch (error: any) {
      console.error('Failed to save file:', error);
      if (error.response && error.response.data && error.response.data.message) {
        showAlert(`Échec de la sauvegarde du fichier: ${error.response.data.message}`, 'error');
      } else {
        showAlert('Échec de la sauvegarde du fichier.', 'error');
      }
    }
  }, [id, code, fileName, imports, nodes, edges, updateGraph, showAlert, width, height]);

  const handleExecute = useCallback(() => {
    console.log(`Dispatching executeNode event for nodeId: ${id}`);
    const event = new CustomEvent('executeNode', { detail: { nodeId: id } });
    window.dispatchEvent(event);
  }, [id]);

  const handleDelete = useCallback(() => {
    deleteNode(id);
  }, [id, deleteNode]);

  const handleClone = useCallback(() => {
    cloneNode(id);
  }, [id, cloneNode]);

  return (
    <ResizableBox width={width} height={height} onResize={handleResize} minConstraints={[200, 200]} maxConstraints={[600, 600]}>
      <Box borderWidth={1} borderRadius="lg" p={3} bg="white" width="100%" height="100%">
        <VStack spacing={3}>
          <Input
            value={fileName}
            onChange={(e) => setFileName(e.target.value)}
            placeholder="Nom du fichier"
          />
          <Box>
            <Text fontWeight="bold">Imports Internes :</Text>
            <Select
              isMulti
              options={availableImports}
              value={availableImports.filter(option => imports.includes(option.value))}
              onChange={handleImportChange}
              placeholder="Sélectionner des imports"
            />
          </Box>
          <Box height={150} width="100%">
            <MonacoEditor
              height="100%"
              language="javascript"
              theme="vs-dark"
              value={code}
              onChange={(value) => setCode(value || '')}
              options={{ minimap: { enabled: false } }}
            />
          </Box>
          {data.lintErrors && data.lintErrors.length > 0 && (
            <Box>
              <Text color="red.500" fontWeight="bold">Erreurs de lint :</Text>
              {data.lintErrors.map((error: any, index: number) => (
                <Text key={index} color="red.500">{`Ligne ${error.line}: ${error.message}`}</Text>
              ))}
            </Box>
          )}
          <HStack spacing={2}>
            <Button size="sm" colorScheme="blue" onClick={handleSave}>Sauvegarder</Button>
            <Button size="sm" colorScheme="green" onClick={handleExecute}>Exécuter</Button>
            <Button size="sm" colorScheme="red" onClick={handleDelete}>Supprimer</Button>
            <Button size="sm" colorScheme="purple" onClick={handleClone}>Cloner</Button>
          </HStack>
        </VStack>
        <Handle type="target" position={Position.Top} />
        <Handle type="source" position={Position.Bottom} />
      </Box>
    </ResizableBox>
  );
};

export default CodeNode;


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/Console.tsx

// frontend/src/components/Console.tsx

import React, { useState, useEffect } from 'react';
import { Box, Text, VStack, Button, Input, HStack } from '@chakra-ui/react';
import { useCombined } from '../contexts/CombinedContext'; // Utiliser useCombined
import axiosInstance from '../axiosInstance';
import { useAlert } from '../contexts/AlertContext';
import { useModal } from '../contexts/ModalContext'; // Utiliser useModalContext

export const Console: React.FC = () => {
  const [output, setOutput] = useState('');
  const [command, setCommand] = useState('');
  const { executeNode } = useCombined(); // Utiliser useCombined
  const { selectedProject } = useCombined(); // Utiliser useCombined
  const { showAlert } = useAlert();

  useEffect(() => {
    const handleNodeExecution = async (event: Event) => {
      const customEvent = event as CustomEvent;
      try {
        const result = await executeNode(customEvent.detail.nodeId);
        const newOutput = `${result.stdout}\n${result.stderr}`;
        console.log('New Output:', newOutput);
        setOutput(prevOutput => `${prevOutput}\n${newOutput}`);
      } catch (error) {
        const errorOutput = `Erreur lors de l'exécution du nœud: ${error}`;
        console.log(errorOutput);
        setOutput(prevOutput => `${prevOutput}\n${errorOutput}`);
        showAlert('Erreur lors de l\'exécution du nœud.', 'error');
      }
    };

    window.addEventListener('executeNode', handleNodeExecution);

    return () => {
      window.removeEventListener('executeNode', handleNodeExecution);
    };
  }, [executeNode, showAlert]);

  const executeCommand = async () => {
    if (!command.trim()) return;

    try {
      const response = await axiosInstance.post('/execute-command', {
        project: selectedProject,
        command,
      });
      const newOutput = `${response.data.stdout}\n${response.data.stderr}`;
      setOutput(prevOutput => `${prevOutput}\n${newOutput}`);
      setCommand('');
      showAlert('Commande exécutée avec succès.', 'success');
    } catch (error: any) {
      const errorOutput = `Erreur lors de l'exécution de la commande: ${error.response?.data?.message || error.message}`;
      setOutput(prevOutput => `${prevOutput}\n${errorOutput}`);
      showAlert('Erreur lors de l\'exécution de la commande.', 'error');
    }
  };

  const clearConsole = () => {
    setOutput('');
  };

  return (
    <Box width="100%" p={4} bg="gray.100">
      <VStack spacing={4} align="stretch">
        <Text fontSize="xl" fontWeight="bold">Sortie de la Console</Text>
        <Box
          bg="white"
          color="black"
          p={2}
          borderRadius="md"
          height="calc(50vh - 150px)"
          overflowY="auto"
        >
          <pre>{output}</pre>
        </Box>
        <HStack>
          <Input
            placeholder="Entrez une commande"
            value={command}
            onChange={(e) => setCommand(e.target.value)}
          />
          <Button colorScheme="blue" onClick={executeCommand}>Exécuter</Button>
        </HStack>
        <Button colorScheme="red" onClick={clearConsole}>Effacer la Console</Button>
      </VStack>
    </Box>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/ErrorBoundary.tsx

// frontend/src/components/ErrorBoundary.tsx

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Box, Text, Button } from '@chakra-ui/react';
import { useAlert } from '../contexts/AlertContext';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <Box p={4} bg="red.100" color="red.800" borderRadius="md">
          <Text fontSize="xl" fontWeight="bold">Oops, there was an error!</Text>
          <Text mt={2}>{this.state.error?.message}</Text>
          <Button
            mt={4}
            colorScheme="red"
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try again
          </Button>
        </Box>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/GraphCanvas.tsx

// frontend/src/components/GraphCanvas.tsx

import React, { useCallback, useState, useRef, useEffect } from 'react';
import ReactFlow, {
    Background,
    Controls,
    MiniMap,
    applyNodeChanges,
    applyEdgeChanges,
    NodeChange,
    EdgeChange,
    Connection,
    Node,
    Edge,
    useReactFlow, // **Import ajouté ici**
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Box, Button, Input, VStack, HStack, Text, Select } from '@chakra-ui/react';
import { useCombined } from '../contexts/CombinedContext';
import CodeNode from './CodeNode';
import { useModal } from '../contexts/ModalContext';
import { useAlert } from '../contexts/AlertContext';
import axiosInstance from '../axiosInstance';

const nodeTypes = {
    code: CodeNode,
};

const UPDATE_DELAY = 1000; // Délai en millisecondes avant la mise à jour

export const GraphCanvas: React.FC = () => {
    const {
      nodes,
      edges,
      updateGraph,
      addNode,
      deleteNode,
      cloneNode,
      executeNode,
      selectedProject,
      loadGraph,
    } = useCombined();
    const [selectedConnection, setSelectedConnection] = useState<Connection | null>(null);
    const { openModal, closeModal, setModalContent } = useModal();
    const [searchTerm, setSearchTerm] = useState('');
    const { fitView } = useReactFlow(); // Utilisation de useReactFlow après l'importation correcte
    const { showAlert } = useAlert();

    const [nodesState, setNodesState] = useState<Node[]>(nodes);
    const [edgesState, setEdgesState] = useState<Edge[]>(edges);
    const updateTimerRef = useRef<NodeJS.Timeout | null>(null);

    useEffect(() => {
        setNodesState(nodes);
        setEdgesState(edges);
    }, [nodes, edges]);

    const refreshGraph = useCallback(async () => {
        if (selectedProject) {
            try {
                await loadGraph(selectedProject);
                showAlert('Graphe rafraîchi avec succès', 'success');
            } catch (error) {
                console.error('Erreur lors du rafraîchissement du graphe:', error);
                showAlert('Échec du rafraîchissement du graphe', 'error');
            }
        }
    }, [selectedProject, loadGraph, showAlert]);

    useEffect(() => {
        if (selectedProject) {
            console.log("Rafraîchissement du graphe pour le projet:", selectedProject);
            refreshGraph();
        }
    }, [selectedProject]);

    const scheduleUpdate = useCallback((updatedNodes: Node[], updatedEdges: Edge[]) => {
        if (updateTimerRef.current) {
            clearTimeout(updateTimerRef.current);
        }
        updateTimerRef.current = setTimeout(async () => {
            try {
                await updateGraph(updatedNodes, updatedEdges);
                await refreshGraph();
                showAlert('Graphe mis à jour et rafraîchi', 'success');
            } catch (error) {
                console.error('Erreur lors de la mise à jour du graphe:', error);
                showAlert('Échec de la mise à jour du graphe', 'error');
            }
        }, UPDATE_DELAY);
    }, [updateGraph, refreshGraph, showAlert]);

    const onNodesChangeCallback = useCallback(
        (changes: NodeChange[]) => {
            const updatedNodes = applyNodeChanges(changes, nodesState);
            setNodesState(updatedNodes);
            scheduleUpdate(updatedNodes, edgesState);
        },
        [nodesState, edgesState, scheduleUpdate]
    );

    const onEdgesChangeCallback = useCallback(
        (changes: EdgeChange[]) => {
            const updatedEdges = applyEdgeChanges(changes, edgesState);
            setEdgesState(updatedEdges);
            scheduleUpdate(nodesState, updatedEdges);
        },
        [edgesState, nodesState, scheduleUpdate]
    );

    const onConnect = useCallback(
        (connection: Connection) => {
            setSelectedConnection(connection);
            setModalContent(
                'delete', // ou 'connect', selon votre implémentation
                { nodeId: connection.source }
            );
            openModal('delete', { nodeId: connection.source });
        },
        [openModal, setModalContent]
    );

    const handleAddNode = useCallback(() => {
        const newFileName = `newFile_${Date.now()}.js`;
        const newNode: Node = {
            id: newFileName,
            type: 'code',
            position: { x: Math.random() * 500, y: Math.random() * 500 },
            data: { code: '// New node', fileName: newFileName, imports: [], exportedFunctions: [] },
        };
        addNode(newNode);
    }, [addNode]);

    const handleSearch = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(event.target.value);
    }, []);

    const focusNode = useCallback((nodeId: string) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node) {
            fitView({ nodes: [node], duration: 800 });
        }
    }, [nodes, fitView]);

    const onEdgeClick = useCallback(
        (event: React.MouseEvent, edge: Edge) => {
            event.stopPropagation();
            setModalContent('delete', { edgeId: edge.id });
            openModal('delete', { edgeId: edge.id });
        },
        [openModal, setModalContent]
    );

    const handleDeleteEdge = useCallback((edgeId: string) => {
        const updatedEdges = edgesState.filter((e) => e.id !== edgeId);
        setEdgesState(updatedEdges);
        scheduleUpdate(nodesState, updatedEdges);
        closeModal();
    }, [edgesState, nodesState, scheduleUpdate, closeModal]);

    const filteredNodes = React.useMemo(() => {
        return nodesState.filter(node =>
            node.data.fileName.toLowerCase().includes(searchTerm.toLowerCase()) ||
            node.data.code.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [nodesState, searchTerm]);

    return (
        <Box width="60%" height="100%" position="relative">
            <ReactFlow
                nodes={nodesState}
                edges={edgesState}
                onNodesChange={onNodesChangeCallback}
                onEdgesChange={onEdgesChangeCallback}
                onConnect={onConnect}
                nodeTypes={nodeTypes}
                onEdgeClick={onEdgeClick}
                fitView
                panOnScroll
                elementsSelectable
                nodesDraggable
            >
                <Background />
                <Controls />
                <MiniMap />
            </ReactFlow>
            <VStack position="absolute" top={4} left={4} spacing={2} align="stretch">
                <Input
                    placeholder="Rechercher des nœuds..."
                    value={searchTerm}
                    onChange={handleSearch}
                    bg="white"
                    width="200px"
                />
                {searchTerm && (
                    <Box bg="white" borderRadius="md" p={2} maxHeight="200px" overflowY="auto">
                        {filteredNodes.map(node => (
                            <HStack key={node.id} justify="space-between" p={1} _hover={{ bg: "gray.100" }}>
                                <Text>{node.data.fileName}</Text>
                                <Button size="sm" onClick={() => focusNode(node.id)}>Focus</Button>
                            </HStack>
                        ))}
                    </Box>
                )}
            </VStack>
            <Button position="absolute" bottom={4} left={4} colorScheme="teal" onClick={handleAddNode}>
                Ajouter Nœud
            </Button>
            <Button
                position="absolute"
                bottom={4}
                right={4}
                colorScheme="blue"
                onClick={() => scheduleUpdate(nodesState, edgesState)}
            >
                Sauvegarder tout
            </Button>
            <Button
                position="absolute"
                bottom={16}
                right={4}
                colorScheme="green"
                onClick={refreshGraph}
            >
                Rafraîchir le graphe
            </Button>
        </Box>
    );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/Header.tsx

import React from 'react';
import { Box, Flex, Text, Button } from '@chakra-ui/react';
import { useAuth } from '../contexts/AuthContext';
import { useModal } from '../contexts/ModalContext';
import { useAlert } from '../contexts/AlertContext';

export const Header: React.FC = () => {
  const { isAuthenticated, logout } = useAuth();
  const { openModal } = useModal();
  const { showAlert } = useAlert();

  const handleLogout = () => {
    logout();
    showAlert('Déconnecté avec succès.', 'info');
  };

  return (
    <Flex bg="teal.500" color="white" p={4} align="center" justify="space-between">
      <Text fontSize="lg" fontWeight="bold">Low-Code App</Text>
      {isAuthenticated && (
        <Button colorScheme="red" size="sm" onClick={handleLogout}>
          Déconnexion
        </Button>
      )}
    </Flex>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/ImportExportManager.tsx

import React, { useState } from 'react';
import { Box, VStack, HStack, Input, Button, Text, List, ListItem, IconButton } from '@chakra-ui/react';
import { AddIcon, DeleteIcon } from '@chakra-ui/icons';

interface ImportExportManagerProps {
  imports: Array<{ from: string; items: string[] }>;
  exports: string[];
  onImportsChange: (imports: Array<{ from: string; items: string[] }>) => void;
  onExportsChange: (exports: string[]) => void;
}

const ImportExportManager: React.FC<ImportExportManagerProps> = ({
  imports,
  exports,
  onImportsChange,
  onExportsChange,
}) => {
  const [newImportFrom, setNewImportFrom] = useState('');
  const [newImportItem, setNewImportItem] = useState('');
  const [newExport, setNewExport] = useState('');

  const handleAddImport = () => {
    if (newImportFrom && newImportItem) {
      const existingImport = imports.find(imp => imp.from === newImportFrom);
      if (existingImport) {
        existingImport.items.push(newImportItem);
      } else {
        imports.push({ from: newImportFrom, items: [newImportItem] });
      }
      onImportsChange([...imports]);
      setNewImportFrom('');
      setNewImportItem('');
    }
  };

  const handleRemoveImport = (from: string, item: string) => {
    const updatedImports = imports.map(imp => {
      if (imp.from === from) {
        return { ...imp, items: imp.items.filter(i => i !== item) };
      }
      return imp;
    }).filter(imp => imp.items.length > 0);
    onImportsChange(updatedImports);
  };

  const handleAddExport = () => {
    if (newExport && !exports.includes(newExport)) {
      onExportsChange([...exports, newExport]);
      setNewExport('');
    }
  };

  const handleRemoveExport = (item: string) => {
    onExportsChange(exports.filter(exp => exp !== item));
  };

  return (
    <Box>
      <VStack align="stretch" spacing={4}>
        <Box>
          <Text fontWeight="bold">Imports:</Text>
          <List spacing={2}>
            {imports.map((imp, index) => (
              <ListItem key={index}>
                <Text>From: {imp.from}</Text>
                <List pl={4}>
                  {imp.items.map((item, itemIndex) => (
                    <ListItem key={itemIndex}>
                      <HStack>
                        <Text>{item}</Text>
                        <IconButton
                          aria-label="Remove import"
                          icon={<DeleteIcon />}
                          size="xs"
                          onClick={() => handleRemoveImport(imp.from, item)}
                        />
                      </HStack>
                    </ListItem>
                  ))}
                </List>
              </ListItem>
            ))}
          </List>
          <HStack mt={2}>
            <Input
              placeholder="From module"
              value={newImportFrom}
              onChange={(e) => setNewImportFrom(e.target.value)}
            />
            <Input
              placeholder="Import item"
              value={newImportItem}
              onChange={(e) => setNewImportItem(e.target.value)}
            />
            <Button onClick={handleAddImport}>
              <AddIcon />
            </Button>
          </HStack>
        </Box>
        <Box>
          <Text fontWeight="bold">Exports:</Text>
          <List spacing={2}>
            {exports.map((exp, index) => (
              <ListItem key={index}>
                <HStack>
                  <Text>{exp}</Text>
                  <IconButton
                    aria-label="Remove export"
                    icon={<DeleteIcon />}
                    size="xs"
                    onClick={() => handleRemoveExport(exp)}
                  />
                </HStack>
              </ListItem>
            ))}
          </List>
          <HStack mt={2}>
            <Input
              placeholder="Export item"
              value={newExport}
              onChange={(e) => setNewExport(e.target.value)}
            />
            <Button onClick={handleAddExport}>
              <AddIcon />
            </Button>
          </HStack>
        </Box>
      </VStack>
    </Box>
  );
};

export default ImportExportManager;

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/LoginModal.tsx

import React, { useState } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Input,
  VStack,
  Text,
} from '@chakra-ui/react';
import { useModal } from '../contexts/ModalContext';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const LoginModal: React.FC = () => {
  const { isOpen, closeModal, modalContent } = useModal();
  const { login } = useAuth();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleLogin = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await login(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  // Vérifiez si le modal actuel est le LoginModal
  if (modalContent !== 'login') return null;

  return (
    <Modal isOpen={isOpen} onClose={closeModal}>
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Connexion</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4}>
            <Input
              placeholder="Nom d'utilisateur"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            <Input
              type="password"
              placeholder="Mot de passe"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </VStack>
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="blue" mr={3} onClick={handleLogin} isLoading={isSubmitting}>
            Connexion
          </Button>
          <Button variant="ghost" onClick={() => {
            closeModal();
            // Optionnel : Ouvrir le RegisterModal si nécessaire
          }}>
            Annuler
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/MainApp.tsx

import React from 'react';
import { Box, Flex } from '@chakra-ui/react';
import { Sidebar } from './Sidebar';
import { GraphCanvas } from './GraphCanvas';
import { Console } from './Console';
import { ProjectStructure } from './ProjectStructure';

export const MainApp: React.FC = () => {
  return (
    <Flex height="calc(100vh - 60px)"> {/* Ajustez la hauteur en fonction de votre en-tête */}
      <Sidebar />
      <Box flex={1} display="flex">
        <GraphCanvas />
        <Box width="40%" display="flex" flexDirection="column">
          <ProjectStructure />
          <Console />
        </Box>
      </Box>
    </Flex>
  );
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/Modals.tsx

// frontend/src/components/Modals.tsx

import React from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Text,
  useDisclosure,
} from '@chakra-ui/react';
import { useGraph } from '../contexts/GraphContext';

export const Modals: React.FC = () => {
  const { isOpen: isDeleteModalOpen, onOpen: onDeleteModalOpen, onClose: onDeleteModalClose } = useDisclosure();
  const { deleteNode } = useGraph();
  const [nodeToDelete, setNodeToDelete] = React.useState<string | null>(null);

  // This function would be called from a parent component or through an event system
  const openDeleteModal = (nodeId: string) => {
    setNodeToDelete(nodeId);
    onDeleteModalOpen();
  };

  const handleConfirmDelete = () => {
    if (nodeToDelete) {
      deleteNode(nodeToDelete);
      onDeleteModalClose();
      setNodeToDelete(null);
    }
  };

  return (
    <>
      {/* Delete Node Modal */}
      <Modal isOpen={isDeleteModalOpen} onClose={onDeleteModalClose}>
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Confirm Deletion</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            <Text>Are you sure you want to delete this node? This action cannot be undone.</Text>
          </ModalBody>
          <ModalFooter>
            <Button colorScheme="red" mr={3} onClick={handleConfirmDelete}>
              Delete
            </Button>
            <Button variant="ghost" onClick={onDeleteModalClose}>Cancel</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* You can add more modals here as needed */}
      {/* For example: Edit Node Modal, Create Connection Modal, etc. */}
    </>
  );
};

// This function should be exported and used in parent components to open the delete modal
export const useModals = () => {
  const { isOpen: isDeleteModalOpen, onOpen: onDeleteModalOpen, onClose: onDeleteModalClose } = useDisclosure();

  const openDeleteModal = (nodeId: string) => {
    // Logic to set the node to delete and open the modal
    onDeleteModalOpen();
  };

  return {
    openDeleteModal,
    isDeleteModalOpen,
    onDeleteModalClose,
  };
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/ProjectControls.tsx

import React from 'react';
import { Button, HStack } from '@chakra-ui/react';
import axiosInstance from '../axiosInstance';
import { useProject } from '../contexts/ProjectContext';
import { useAlert } from '../contexts/AlertContext';

export const ProjectControls: React.FC = () => {
  const { selectedProject } = useProject();
  const { showAlert } = useAlert();

  const handleCommit = async () => {
    try {
      await axiosInstance.post('/git/commit', {
        project: selectedProject,
        message: 'Commit via Low-Code Interface',
      });
      showAlert('Modifications commitées avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du commit: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  const handlePush = async () => {
    try {
      await axiosInstance.post('/git/push', {
        project: selectedProject,
      });
      showAlert('Modifications poussées vers GitHub avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du push: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  const handlePull = async () => {
    try {
      await axiosInstance.post('/git/pull', {
        project: selectedProject,
      });
      showAlert('Modifications récupérées depuis GitHub avec succès.', 'success');
    } catch (error: any) {
      showAlert(`Erreur lors du pull: ${error.response?.data?.message || error.message}`, 'error');
    }
  };

  return (
    <HStack spacing={4}>
      <Button colorScheme="yellow" onClick={handleCommit}>
        Commit
      </Button>
      <Button colorScheme="green" onClick={handlePush}>
        Push
      </Button>
      <Button colorScheme="blue" onClick={handlePull}>
        Pull
      </Button>
    </HStack>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/ProjectStructure.tsx

// frontend/src/components/ProjectStructure.tsx

import React from 'react';
import { Box, Text, VStack, HStack, Icon } from '@chakra-ui/react';
import { FaFolder, FaFile } from 'react-icons/fa';
import { useGraph } from '../contexts/GraphContext';

interface FileTreeNode {
  name: string;
  type: 'file' | 'folder';
  children?: FileTreeNode[];
}

const FileTreeItem: React.FC<{ node: FileTreeNode; depth: number }> = ({ node, depth }) => {
  return (
    <VStack align="start" pl={depth * 4} spacing={1}>
      <HStack>
        <Icon as={node.type === 'folder' ? FaFolder : FaFile} color={node.type === 'folder' ? 'yellow.500' : 'blue.500'} />
        <Text>{node.name}</Text>
      </HStack>
      {node.children && node.children.map((child, index) => (
        <FileTreeItem key={index} node={child} depth={depth + 1} />
      ))}
    </VStack>
  );
};

export const ProjectStructure: React.FC = () => {
  const { nodes } = useGraph();

  const fileTree: FileTreeNode = {
    name: 'Project Root',
    type: 'folder',
    children: nodes.map(node => ({
      name: node.data.fileName,
      type: 'file'
    }))
  };

  return (
    <Box width="100%" p={4} bg="gray.50" overflowY="auto" height="50vh">
      <Text fontSize="xl" fontWeight="bold" mb={4}>Project Structure</Text>
      <FileTreeItem node={fileTree} depth={0} />
    </Box>
  );
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/ProtectedRoute.tsx

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // Redirect to the login page with the current location as state
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/RegisterModal.tsx

// frontend/src/components/RegisterModal.tsx

import React, { useState } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  Input,
  VStack,
  Text,
} from '@chakra-ui/react';
import { useModal } from '../contexts/ModalContext';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const RegisterModal: React.FC = () => {
  const { isOpen, closeModal, modalContent } = useModal();
  const { register } = useAuth();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleRegister = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await register(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  // Vérifiez si le modal actuel est le RegisterModal
  if (modalContent !== 'register') return null;

  return (
    <Modal isOpen={isOpen} onClose={closeModal}>
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Inscription</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4}>
            <Input
              placeholder="Nom d'utilisateur"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            <Input
              type="password"
              placeholder="Mot de passe"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </VStack>
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="green" mr={3} onClick={handleRegister} isLoading={isSubmitting}>
            Inscription
          </Button>
          <Button variant="ghost" onClick={() => {
            closeModal();
            // Optionnel : Ouvrir le LoginModal si nécessaire
          }}>
            Annuler
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/Sidebar.tsx

// frontend/src/components/Sidebar.tsx

import React, { useState, useCallback } from 'react';
import {
  Box,
  VStack,
  Input,
  Button,
  Select,
  Text,
  HStack,
} from '@chakra-ui/react';
import { AddIcon } from '@chakra-ui/icons';
import { useCombined } from '../contexts/CombinedContext'; // Utiliser useCombined
import { useAlert } from '../contexts/AlertContext';
import { ProjectControls } from './ProjectControls';
import { useAuth } from '../contexts/AuthContext';
import { useModal } from '../contexts/ModalContext';

export const Sidebar: React.FC = () => {
  const {
    projects,
    selectedProject,
    selectProject,
    createProject,
    installPackage,
    importGitProject,
    deleteProject,
  } = useCombined(); // Utiliser useCombined
  const [newProjectCode, setNewProjectCode] = useState('');
  const [newProjectName, setNewProjectName] = useState('');
  const [packageName, setPackageName] = useState('');
  const [gitRepoUrl, setGitRepoUrl] = useState('');
  const { showAlert } = useAlert();
  const { isAuthenticated, logout } = useAuth();
  const { openModal } = useModal();

  const handleCreateProject = async () => {
    if (newProjectCode && newProjectName) {
      try {
        await createProject(newProjectCode, newProjectName);
        setNewProjectCode('');
        setNewProjectName('');
        showAlert('Projet créé avec succès.', 'success');
      } catch (error: any) {
        showAlert(
          `Erreur lors de la création du projet: ${error.response?.data?.message || error.message}`,
          'error'
        );
      }
    } else {
      showAlert('Code et nom du projet sont requis.', 'warning');
    }
  };

  const handleSelectProject = async (projectName: string) => {
    selectProject(projectName);
    showAlert(`Projet "${projectName}" sélectionné.`, 'info');
  };

  const handleInstallPackage = async () => {
    if (packageName) {
      try {
        await installPackage(packageName);
        setPackageName('');
        showAlert(`Package "${packageName}" installé avec succès.`, 'success');
      } catch (error: any) {
        showAlert(
          `Erreur lors de l'installation du package: ${error.response?.data?.message || error.message}`,
          'error'
        );
      }
    } else {
      showAlert('Nom du package requis.', 'warning');
    }
  };

  const handleGitPull = async () => {
    if (!gitRepoUrl) {
      showAlert("L'URL du dépôt Git est requise.", 'warning');
      return;
    }

    try {
      await importGitProject(gitRepoUrl);
      showAlert('Projet Git importé avec succès.', 'success');
      setGitRepoUrl('');
    } catch (error: any) {
      showAlert(`Erreur lors de l'importation du projet Git: ${error.message}`, 'error');
    }
  };

  const handleDeleteProject = async (projectName: string) => {
    if (window.confirm(`Êtes-vous sûr de vouloir supprimer le projet "${projectName}" ?`)) {
      try {
        await deleteProject(projectName);
        showAlert(`Projet "${projectName}" supprimé avec succès.`, 'success');
      } catch (error: any) {
        showAlert(`Erreur lors de la suppression du projet: ${error.message}`, 'error');
      }
    }
  };

  const handleLogout = () => {
    logout();
    showAlert('Déconnecté avec succès.', 'info');
  };

  return (
    <Box width="20%" p={4} bg="gray.100" overflowY="auto" height="100vh">
      <VStack spacing={6} align="stretch">
        <Text fontSize="2xl" fontWeight="bold" textAlign="center">
          Gestion de Projet
        </Text>

        {isAuthenticated ? (
          <>
            <VStack align="stretch" spacing={2}>
              <Input
                placeholder="Code du Projet"
                value={newProjectCode}
                onChange={(e) => setNewProjectCode(e.target.value)}
              />
              <Input
                placeholder="Nom du Projet"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
              />
              <Button
                colorScheme="teal"
                leftIcon={<AddIcon />}
                onClick={handleCreateProject}
              >
                Créer Projet
              </Button>
            </VStack>

            <Select
              placeholder="Sélectionner un Projet"
              value={selectedProject}
              onChange={(e) => handleSelectProject(e.target.value)}
            >
              {projects.map((project) => (
                <option key={project._id} value={project.name}>
                  {project.name}
                </option>
              ))}
            </Select>

            {selectedProject && (
              <>
                <VStack align="stretch" spacing={2}>
                  <Input
                    placeholder="Nom du Package"
                    value={packageName}
                    onChange={(e) => setPackageName(e.target.value)}
                  />
                  <Button
                    colorScheme="blue"
                    leftIcon={<AddIcon />}
                    onClick={handleInstallPackage}
                  >
                    Installer Package
                  </Button>
                </VStack>
                <Button
                  colorScheme="red"
                  onClick={() => handleDeleteProject(selectedProject)}
                >
                  Supprimer le projet
                </Button>
              </>
            )}

            <VStack align="stretch" spacing={2}>
              <Input
                placeholder="URL du dépôt Git"
                value={gitRepoUrl}
                onChange={(e) => setGitRepoUrl(e.target.value)}
              />
              <Button
                colorScheme="purple"
                onClick={handleGitPull}
              >
                Importer depuis Git
              </Button>
            </VStack>

            <ProjectControls />

            <Button colorScheme="red" onClick={handleLogout}>
              Déconnexion
            </Button>
          </>
        ) : (
          <VStack align="stretch" spacing={2}>
            <Button colorScheme="blue" onClick={() => openModal('login')}>
              Connexion
            </Button>
            <Button colorScheme="green" onClick={() => openModal('register')}>
              Inscription
            </Button>
          </VStack>
        )}
      </VStack>
    </Box>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/components/SimpleModal.tsx



---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/AlertContext.tsx

// frontend/src/contexts/AlertContext.tsx

import React, { createContext, useState, useContext, ReactNode } from 'react';
import { useToast } from '@chakra-ui/react';

interface AlertContextType {
  showAlert: (message: string, status: 'success' | 'error' | 'info' | 'warning') => void;
}

const AlertContext = createContext<AlertContextType | undefined>(undefined);

export const AlertProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const toast = useToast();

  const showAlert = (message: string, status: 'success' | 'error' | 'info' | 'warning') => {
    toast({
      title: message,
      status: status,
      duration: 3000,
      isClosable: true,
    });
  };

  return (
    <AlertContext.Provider value={{ showAlert }}>
      {children}
    </AlertContext.Provider>
  );
};

export const useAlert = () => {
  const context = useContext(AlertContext);
  if (context === undefined) {
    throw new Error('useAlert must be used within an AlertProvider');
  }
  return context;
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/AuthContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';

interface AuthContextType {
  isAuthenticated: boolean;
  token: string | null;
  login: (username: string, password: string) => Promise<void>;
  register: (username: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [token, setToken] = useState<string | null>(() => localStorage.getItem('token'));
  const { showAlert } = useAlert();

  useEffect(() => {
    if (token) {
      localStorage.setItem('token', token);
    } else {
      localStorage.removeItem('token');
    }
  }, [token]);

  const login = async (username: string, password: string) => {
    try {
      const response = await axiosInstance.post('/auth/login', { username, password });
      setToken(response.data.token);
      showAlert('Connexion réussie.', 'success');
    } catch (error: any) {
      const message = error.response?.data?.message || 'Échec de la connexion.';
      showAlert(message, 'error');
      throw error;
    }
  };

  const register = async (username: string, password: string) => {
    try {
      await axiosInstance.post('/auth/register', { username, password });
      showAlert('Inscription réussie. Vous pouvez maintenant vous connecter.', 'success');
    } catch (error: any) {
      const message = error.response?.data?.message || 'Échec de l\'inscription.';
      showAlert(message, 'error');
      throw error;
    }
  };

  const logout = () => {
    setToken(null);
    showAlert('Déconnexion réussie.', 'info');
  };

  const isAuthenticated = Boolean(token);

  return (
    <AuthContext.Provider value={{ isAuthenticated, token, login, register, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth doit être utilisé dans un AuthProvider');
  }
  return context;
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/CombinedContext.tsx

// frontend/src/contexts/CombinedContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import { Node, Edge } from 'reactflow';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';
import { useGraph } from './GraphContext';
import { useProject } from './ProjectContext';

interface Project {
  _id: string;
  name: string;
  createdAt: string;
}

interface CombinedContextType {
  projects: Project[];
  selectedProject: string;
  nodes: Node[];
  edges: Edge[];
  loadProjects: () => Promise<void>;
  selectProject: (project: string) => void;
  createProject: (projectCode: string, projectName: string) => Promise<void>;
  installPackage: (packageName: string) => Promise<void>;
  importGitProject: (repoUrl: string) => Promise<void>;
  deleteProject: (projectName: string) => Promise<void>;
  loadGraph: () => Promise<void>;
  updateGraph: (updatedNodes: Node[], updatedEdges: Edge[]) => Promise<void>;
  addNode: (newNode: Node) => void;
  deleteNode: (nodeId: string) => Promise<void>;
  cloneNode: (nodeId: string) => Promise<void>;
  executeNode: (nodeId: string) => Promise<{ stdout: string; stderr: string }>;
}

const CombinedContext = createContext<CombinedContextType | undefined>(undefined);

export const CombinedProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { projects, selectedProject, selectProject, loadProjects, createProject, installPackage, importGitProject, deleteProject } = useProject();
  const { nodes, edges, loadGraph, updateGraph, addNode, deleteNode, cloneNode, executeNode } = useGraph();
  const { showAlert } = useAlert();

  // Charger le graphe lorsque le projet sélectionné change
  useEffect(() => {
    if (selectedProject) {
      loadGraph(selectedProject);
    }
  }, [selectedProject, loadGraph]);

  const handleUpdateGraph = async (updatedNodes: Node[], updatedEdges: Edge[]) => {
    try {
      await updateGraph(selectedProject, updatedNodes, updatedEdges);
    } catch (error) {
      // L'erreur est déjà gérée dans GraphProvider
    }
  };

  const contextValue: CombinedContextType = {
    projects,
    selectedProject,
    nodes,
    edges,
    loadProjects,
    selectProject,
    createProject,
    installPackage,
    importGitProject,
    deleteProject,
    loadGraph: () => loadGraph(selectedProject),
    updateGraph: handleUpdateGraph,
    addNode,
    deleteNode,
    cloneNode,
    executeNode
  };

  return (
    <CombinedContext.Provider value={contextValue}>
      {children}
    </CombinedContext.Provider>
  );
};

export const useCombined = () => {
  const context = useContext(CombinedContext);
  if (!context) {
    throw new Error('useCombined must be used within a CombinedProvider');
  }
  return context;
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/GraphContext.tsx

// frontend/src/contexts/GraphContext.tsx

import React, { createContext, useState, useContext, ReactNode, useCallback } from 'react';
import { Node, Edge } from 'reactflow';
import axiosInstance from '../axiosInstance';
import { useAlert } from './AlertContext';

interface GraphContextType {
  nodes: Node[];
  edges: Edge[];
  loadGraph: (project: string) => Promise<void>;
  updateGraph: (project: string, updatedNodes: Node[], updatedEdges: Edge[]) => Promise<void>;
  addNode: (newNode: Node) => void;
  deleteNode: (nodeId: string) => Promise<void>;
  cloneNode: (nodeId: string) => Promise<void>;
  executeNode: (nodeId: string) => Promise<{ stdout: string; stderr: string }>;
}

const GraphContext = createContext<GraphContextType | undefined>(undefined);

export const GraphProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const { showAlert } = useAlert();

  const loadGraph = useCallback(async (project: string) => {
    try {
      const response = await axiosInstance.get('/project-graph', {
        params: { project },
      });
      setNodes(response.data.graph.nodes);
      setEdges(response.data.graph.edges);
      showAlert('Graphe chargé avec succès.', 'success');
    } catch (error) {
      console.error('Échec du chargement du graphe du projet:', error);
      showAlert('Échec du chargement du graphe du projet.', 'error');
    }
  }, [showAlert]);

  const updateGraph = async (project: string, updatedNodes: Node[], updatedEdges: Edge[]) => {
    try {
      const response = await axiosInstance.post('/project-graph/update-graph', {
        project,
        nodes: updatedNodes,
        edges: updatedEdges
      });
      console.log('Réponse de mise à jour du graphe:', response.data);
      setNodes(updatedNodes);
      setEdges(updatedEdges);
      showAlert('Graphe mis à jour avec succès.', 'success');
    } catch (error) {
      console.error('Échec de la mise à jour du graphe:', error);
      showAlert('Échec de la mise à jour du graphe.', 'error');
      throw error;
    }
  };

  const addNode = (newNode: Node) => {
    setNodes(prevNodes => [...prevNodes, newNode]);
  };

  const deleteNode = async (nodeId: string) => {
    try {
      const response = await axiosInstance.post('/project-graph/delete-node', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId
      });
      console.log('Réponse de suppression du nœud:', response.data);
      setNodes(prevNodes => prevNodes.filter(node => node.id !== nodeId));
      setEdges(prevEdges => prevEdges.filter(edge => edge.source !== nodeId && edge.target !== nodeId));
      showAlert('Nœud supprimé avec succès.', 'success');
    } catch (error) {
      console.error('Échec de la suppression du nœud:', error);
      showAlert('Échec de la suppression du nœud.', 'error');
      throw error;
    }
  };

  const cloneNode = async (nodeId: string) => {
    try {
      const newNodeId = `${nodeId}_clone`;
      const response = await axiosInstance.post('/project-graph/clone-node', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId,
        newNodeId
      });
      console.log('Réponse de clonage du nœud:', response.data);
      setNodes(prevNodes => [...prevNodes, response.data.clonedNode]);
      showAlert('Nœud cloné avec succès.', 'success');
    } catch (error) {
      console.error('Échec du clonage du nœud:', error);
      showAlert('Échec du clonage du nœud.', 'error');
      throw error;
    }
  };

  const executeNode = async (nodeId: string): Promise<{ stdout: string; stderr: string }> => {
    try {
      const response = await axiosInstance.post('/execute', {
        project: '', // Le projet sera passé lors de l'appel
        nodeId
      });
      console.log('Réponse d\'exécution du nœud:', response.data);
      showAlert('Nœud exécuté avec succès.', 'success');
      return { stdout: response.data.stdout, stderr: response.data.stderr };
    } catch (error) {
      console.error('Échec de l\'exécution du nœud:', error);
      showAlert('Échec de l\'exécution du nœud.', 'error');
      throw error;
    }
  };

  return (
    <GraphContext.Provider value={{ nodes, edges, loadGraph, updateGraph, addNode, deleteNode, cloneNode, executeNode }}>
      {children}
    </GraphContext.Provider>
  );
};

export const useGraph = () => {
  const context = useContext(GraphContext);
  if (!context) {
    throw new Error('useGraph doit être utilisé à l\'intérieur d\'un GraphProvider');
  }
  return context;
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/ModalContext.tsx

// frontend/src/contexts/ModalContext.tsx

import React, { createContext, useState, useContext, ReactNode } from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  VStack,
  Text,
  HStack,
} from '@chakra-ui/react';
import { useCombined } from './CombinedContext';
import { useAlert } from './AlertContext';

interface ModalContextType {
  isOpen: boolean;
  openModal: (content: string, data?: any) => void;
  closeModal: () => void;
  modalContent: string | null;
  modalData: any;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export const ModalProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<string | null>(null);
  const [modalData, setModalData] = useState<any>(null);
  const { deleteNode } = useCombined();
  const { showAlert } = useAlert();

  const openModal = (content: string, data: any = null) => {
    setModalContent(content);
    setModalData(data);
    setIsOpen(true);
    console.log(`Modal ouvert: ${content}`, data); // Debug
  };

  const closeModal = () => {
    setIsOpen(false);
    setModalContent(null);
    setModalData(null);
    console.log('Modal fermé'); // Debug
  };

  const handleDelete = async () => {
    if (modalData && modalData.nodeId) {
      try {
        await deleteNode(modalData.nodeId);
        showAlert('Nœud supprimé avec succès.', 'success');
        closeModal();
      } catch (error: any) {
        showAlert('Échec de la suppression du nœud.', 'error');
      }
    }
  };

  const renderModalContent = () => {
    switch (modalContent) {
      case 'login':
        return <LoginForm />;
      case 'register':
        return <RegisterForm />;
      case 'delete':
        return <DeleteNodeForm />;
      // Ajoutez d'autres cas pour différents types de modaux
      default:
        return null;
    }
  };

  return (
    <ModalContext.Provider value={{ isOpen, openModal, closeModal, modalContent, modalData }}>
      {children}
      {isOpen && (
        <Modal isOpen={isOpen} onClose={closeModal} isCentered>
          <ModalOverlay />
          <ModalContent>
            <ModalHeader>
              {modalContent === 'login'
                ? 'Connexion'
                : modalContent === 'register'
                ? 'Inscription'
                : 'Confirmation'}
            </ModalHeader>
            <ModalCloseButton />
            <ModalBody>{renderModalContent()}</ModalBody>
            <ModalFooter>
              {modalContent !== 'delete' && (
                <Button colorScheme="blue" mr={3} onClick={closeModal}>
                  Fermer
                </Button>
              )}
            </ModalFooter>
          </ModalContent>
        </Modal>
      )}
    </ModalContext.Provider>
  );
};

// Hook personnalisé pour utiliser le contexte des modaux
export const useModal = () => {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error('useModal must be used within a ModalProvider');
  }
  return context;
};

// Composant pour le formulaire de connexion
const LoginForm: React.FC = () => {
  const { closeModal } = useModal();
  const { login } = useCombined();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleLogin = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await login(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <VStack spacing={4}>
      <Input
        placeholder="Nom d'utilisateur"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <Input
        type="password"
        placeholder="Mot de passe"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <Button colorScheme="blue" onClick={handleLogin} isLoading={isSubmitting}>
        Connexion
      </Button>
    </VStack>
  );
};

// Composant pour le formulaire d'inscription
const RegisterForm: React.FC = () => {
  const { closeModal } = useModal();
  const { register } = useCombined();
  const { showAlert } = useAlert();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleRegister = async () => {
    if (!username || !password) {
      showAlert('Nom d\'utilisateur et mot de passe requis.', 'warning');
      return;
    }
    setIsSubmitting(true);
    try {
      await register(username, password);
      closeModal();
    } catch (error) {
      // Les erreurs sont gérées dans le contexte Auth
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <VStack spacing={4}>
      <Input
        placeholder="Nom d'utilisateur"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <Input
        type="password"
        placeholder="Mot de passe"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <Button colorScheme="green" onClick={handleRegister} isLoading={isSubmitting}>
        Inscription
      </Button>
    </VStack>
  );
};

// Composant pour la confirmation de suppression de nœud
const DeleteNodeForm: React.FC = () => {
  const { closeModal, modalData } = useModal();
  const { deleteNode } = useCombined();
  const { showAlert } = useAlert();

  const handleDelete = async () => {
    if (modalData && modalData.nodeId) {
      try {
        await deleteNode(modalData.nodeId);
        showAlert('Nœud supprimé avec succès.', 'success');
        closeModal();
      } catch (error: any) {
        showAlert('Échec de la suppression du nœud.', 'error');
      }
    }
  };

  return (
    <VStack spacing={4}>
      <Text>Êtes-vous sûr de vouloir supprimer ce nœud ? Cette action est irréversible.</Text>
      <HStack spacing={4}>
        <Button colorScheme="red" onClick={handleDelete}>
          Supprimer
        </Button>
        <Button variant="ghost" onClick={closeModal}>
          Annuler
        </Button>
      </HStack>
    </VStack>
  );
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/contexts/ProjectContext.tsx

// frontend/src/contexts/ProjectContext.tsx

import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import axiosInstance from '../axiosInstance';
// Supprimer l'import de useGraph
import { useAlert } from './AlertContext';

interface Project {
  _id: string;
  name: string;
  createdAt: string;
}

interface ProjectContextType {
  projects: Project[];
  selectedProject: string;
  selectProject: (project: string) => void;
  loadProjects: () => Promise<void>;
  importGitProject: (repoUrl: string) => Promise<void>;
  deleteProject: (projectName: string) => Promise<void>;
}

const ProjectContext = createContext<ProjectContextType | undefined>(undefined);

export const ProjectProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [selectedProject, setSelectedProject] = useState<string>('');
  // Retirer l'utilisation de useGraph
  const { showAlert } = useAlert();

  const loadProjects = async () => {
    try {
      const response = await axiosInstance.get('/projects');
      setProjects(response.data);
    } catch (error: any) {
      console.error('Failed to load projects:', error);
      showAlert('Échec du chargement des projets.', 'error');
    }
  };

  const selectProject = (project: string) => {
    setSelectedProject(project);
    showAlert(`Projet "${project}" sélectionné.`, 'info');
    // loadGraph est maintenant géré ailleurs
  };

  const importGitProject = async (repoUrl: string) => {
    try {
      const response = await axiosInstance.post("/git/pull", { repoUrl });
      showAlert("Projet Git importé avec succès.", "success");
      await loadProjects();
      if (response.data.projectName) {
        setSelectedProject(response.data.projectName);
      } else {
        showAlert("Le nom du projet n'a pas été trouvé dans la réponse.", "warning");
      }
    } catch (error: any) {
      console.error("Failed to import Git project:", error);
      const errorMessage =
        error.response?.data?.message || "Échec de l'importation du projet Git.";
      showAlert(errorMessage, "error");
      throw error;
    }
  };

  const deleteProject = async (projectName: string) => {
    try {
      await axiosInstance.delete(`/projects/${projectName}`);
      showAlert(`Projet "${projectName}" supprimé avec succès.`, 'success');
      await loadProjects();
      if (selectedProject === projectName) {
        setSelectedProject("");
      }
    } catch (error: any) {
      console.error("Failed to delete project:", error);
      const errorMessage =
        error.response?.data?.message || "Échec de la suppression du projet.";
      showAlert(errorMessage, "error");
      throw error;
    }
  };

  useEffect(() => {
    loadProjects();
  }, []);

  const contextValue: ProjectContextType = {
    projects,
    selectedProject,
    selectProject,
    loadProjects,
    importGitProject,
    deleteProject,
  };

  return (
    <ProjectContext.Provider value={contextValue}>
      {children}
    </ProjectContext.Provider>
  );
};

export const useProject = () => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/edges/index.ts

import type { Edge, EdgeTypes } from '@xyflow/react';

export const initialEdges: Edge[] = [
  { id: 'a->c', source: 'a', target: 'c', animated: true },
  { id: 'b->d', source: 'b', target: 'd' },
  { id: 'c->d', source: 'c', target: 'd', animated: true },
];

export const edgeTypes = {
  // Add your custom edge types here!
} satisfies EdgeTypes;

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/hooks/useAlerts.ts

import { useState } from 'react';

export const useAlerts = () => {
  const [message, setMessage] = useState<string>('');
  const [status, setStatus] = useState<'success' | 'error' | 'info'>('info');
  const [isOpen, setIsOpen] = useState<boolean>(false);

  const showAlert = (msg: string, stat: 'success' | 'error' | 'info') => {
    setMessage(msg);
    setStatus(stat);
    setIsOpen(true);
    setTimeout(() => setIsOpen(false), 3000);
  };

  return { message, status, isOpen, showAlert };
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/hooks/useProjects.ts

import { useState, useEffect } from 'react';
import axios from 'axios';

export const useProjects = () => {
  const [projects, setProjects] = useState<string[]>([]);  // Initialisation avec un tableau vide
  const [selectedProject, setSelectedProject] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const loadProjectGraph = async (project: string) => {
    try {
      setSelectedProject(project);
      const res = await axios.get(`/project-graph?project=${project}`);
      return res.data.graph;
    } catch (error) {
      console.error('Error loading project graph:', error);
    }
  };

  const createProject = async (projectCode: string, projectName: string) => {
    try {
      const res = await axios.post('/create-project', { projectCode, projectName });
      setProjects([...projects, res.data.projectPath]);
    } catch (error) {
      console.error('Error creating project:', error);
    }
  };

  const handleInstallPackage = async (packageName: string) => {
    try {
      const res = await axios.post('/install-package', { project: selectedProject, packageName });
      console.log(res.data.stdout);
    } catch (error) {
      console.error('Error installing package:', error);
    }
  };

  useEffect(() => {
    const fetchProjects = async () => {
      setIsLoading(true);
      try {
        const res = await axios.get('/projects');
        setProjects(res.data || []);  // S'assurer que les données sont un tableau
      } catch (error) {
        console.error('Error loading projects:', error);
        setProjects([]);  // Valeur par défaut en cas d'erreur
      } finally {
        setIsLoading(false);
      }
    };
    fetchProjects();
  }, []);

  return { projects, selectedProject, loadProjectGraph, createProject, handleInstallPackage, isLoading };
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/main.tsx

// frontend/src/main.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { ChakraProvider } from '@chakra-ui/react';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ChakraProvider>
      <App />
    </ChakraProvider>
  </React.StrictMode>
);

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/nodes/PositionLoggerNode.tsx

// my-low-code-app/frontend/src/nodes/PositionLoggerNode.tsx

import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Box, Text } from '@chakra-ui/react';

interface PositionLoggerNodeData {
  label: string;
}

export const PositionLoggerNode: React.FC<NodeProps<PositionLoggerNodeData>> = ({ data }) => {
  return (
    <Box
      p={4}
      borderWidth="1px"
      borderRadius="md"
      bg="white"
      boxShadow="md"
      textAlign="center"
    >
      <Text fontWeight="bold">{data.label}</Text>
      <Handle type="source" position={Position.Bottom} />
    </Box>
  );
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/nodes/index.ts

// my-low-code-app/frontend/src/nodes/index.ts

import type { NodeTypes } from 'reactflow';
import { PositionLoggerNode } from './PositionLoggerNode';

export const nodeTypes = {
  'position-logger': PositionLoggerNode,
} satisfies NodeTypes;

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/nodes/types.ts

import type { Node } from 'reactflow';

export type PositionLoggerNode = Node<{ label: string }, 'position-logger'>;
export type AppNode = PositionLoggerNode;
// Ajoutez d'autres types de nœuds ici si nécessaire

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/pages/LoginPage.tsx

import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Box, VStack, Input, Button, Heading, Text, Link } from '@chakra-ui/react';
import { useAuth } from '../contexts/AuthContext';
import { useAlert } from '../contexts/AlertContext';

export const LoginPage: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const { login } = useAuth();
  const { showAlert } = useAlert();
  const navigate = useNavigate();
  const location = useLocation();

  const handleLogin = async () => {
    try {
      await login(username, password);
      showAlert('Connexion réussie', 'success');
      const origin = (location.state as any)?.from?.pathname || '/';
      navigate(origin);
    } catch (error) {
      showAlert('Échec de la connexion', 'error');
    }
  };

  return (
    <Box maxWidth="400px" margin="auto" mt={8}>
      <VStack spacing={4}>
        <Heading>Connexion</Heading>
        <Input
          placeholder="Nom d'utilisateur"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Mot de passe"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button colorScheme="blue" onClick={handleLogin}>
          Se connecter
        </Button>
        <Text>
          Pas encore de compte ?{' '}
          <Link color="blue.500" onClick={() => navigate('/register')}>
            S'inscrire
          </Link>
        </Text>
      </VStack>
    </Box>
  );
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/pages/RegisterPage.tsx

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, VStack, Input, Button, Heading, Text, Link, useToast } from '@chakra-ui/react';
import axios from '../axiosInstance';

export const RegisterPage: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const navigate = useNavigate();
  const toast = useToast();

  const handleRegister = async () => {
    if (!username || !password) {
      toast({
        title: "Erreur",
        description: "Nom d'utilisateur et mot de passe requis.",
        status: "warning",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    setIsSubmitting(true);
    try {
      const response = await axios.post('/auth/register', { username, password });
      toast({
        title: "Inscription réussie",
        description: response.data.message,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      navigate('/login');
    } catch (error: any) {
      toast({
        title: "Erreur d'inscription",
        description: error.response?.data?.message || "Une erreur est survenue lors de l'inscription.",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Box maxWidth="400px" margin="auto" mt={8}>
      <VStack spacing={4}>
        <Heading>Inscription</Heading>
        <Input
          placeholder="Nom d'utilisateur"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Mot de passe"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button colorScheme="green" onClick={handleRegister} isLoading={isSubmitting}>
          S'inscrire
        </Button>
        <Text>
          Déjà un compte ?{' '}
          <Link color="blue.500" onClick={() => navigate('/login')}>
            Se connecter
          </Link>
        </Text>
      </VStack>
    </Box>
  );
};

---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/utils.ts

// backend/utils.ts

import { Node, Edge } from './types';

/**
 * Function to sanitize variable names.
 * Replace all invalid characters with underscores.
 * @param name Variable name to sanitize.
 * @returns Sanitized variable name.
 */
function sanitizeVariableName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

export function compileNodes(nodes: Node[], entryNodeId: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.error(`Node with id ${nodeId} not found`);
      return;
    }

    // Add imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Add node code within a closure
    const sanitizedFileName = sanitizeVariableName(node.data.fileName);
    compiledCode += `
const ${sanitizedFileName} = (function() {
  const module = { exports: {} };
  const exports = module.exports;
  ${node.data.code}
  return module.exports;
})();
`;

    // Export functions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `if (typeof ${sanitizedFileName}.${func} === 'function') {
  globalThis.${func} = ${sanitizedFileName}.${func};
}\n`;
    });
  }

  // Start compilation from the entry node
  compileNode(entryNodeId);

  return compiledCode;
}


---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/src/vite-env.d.ts



---------
/// my-low-code-app/backend/src/projects/my-low-code/frontend/vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})


---------
/// my-low-code-app/backend/src/routes/authRoutes.ts

// backend/src/routes/authRoutes.ts

import express from 'express';
import { register, login } from '../controllers/authController';

const router = express.Router();

/**
 * @route POST /auth/register
 * @desc Inscription d'un nouvel utilisateur
 * @access Public
 */
router.post('/register', register);

/**
 * @route POST /auth/login
 * @desc Connexion d'un utilisateur existant
 * @access Public
 */
router.post('/login', login);

export default router;


---------
/// my-low-code-app/backend/src/routes/devServerRoutes.ts

// backend/src/routes/devServerRoutes.ts

import express from 'express';
import { startDevServer, stopDevServer } from '../controllers/devServerController';

const router = express.Router();

/**
 * @route POST /dev-server/start
 * @desc Démarre le serveur de développement pour un projet donné.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/start', startDevServer);

/**
 * @route POST /dev-server/stop
 * @desc Arrête le serveur de développement en cours.
 * @access Public (à sécuriser selon vos besoins)
 */
router.post('/stop', stopDevServer);

export default router;


---------
/// my-low-code-app/backend/src/routes/executeRoutes.ts

import express from 'express';
import { executeNode } from '../controllers/executeController';

const router = express.Router();

router.post('/', executeNode);

export default router;


---------
/// my-low-code-app/backend/src/routes/fileRoutes.ts

import express from 'express';
import { updateFile, getAccessibleFunctions } from '../controllers/fileController';

const router = express.Router();

router.post('/', updateFile);
router.get('/accessible-functions', getAccessibleFunctions);

export default router;

---------
/// my-low-code-app/backend/src/routes/gitRoutes.ts

import express from 'express';
import { pullFromGit, commitChanges, pushChanges } from '../controllers/gitController';

const router = express.Router();

router.post('/pull', pullFromGit);
router.post('/commit', commitChanges);
router.post('/push', pushChanges);

export default router;

---------
/// my-low-code-app/backend/src/routes/graphRoutes.ts

// backend/routes/graphRoutes.ts

import express from 'express';
import { getProjectGraph, updateGraph, deleteNode, cloneNode, updateNode } from '../controllers/graphController';

const router = express.Router();

router.get('/', getProjectGraph);
router.post('/update-node', updateNode);
router.post('/update-graph', updateGraph);
router.post('/delete-node', deleteNode);
router.post('/clone-node', cloneNode);

export default router;

---------
/// my-low-code-app/backend/src/routes/importRoutes.ts

import express from 'express';
import { importProject } from '../controllers/importController';
import { authenticateJWT } from '../middleware/auth'; // Si vous avez mis en place l'authentification

const router = express.Router();

/**
 * @route POST /import
 * @desc Importe un projet depuis un fichier JSON
 * @access Protected
 */
router.post('/import', authenticateJWT, importProject);

export default router;


---------
/// my-low-code-app/backend/src/routes/projectRoutes.ts

import express from 'express';
import { getProjects, createProject, installPackage, deleteProject } from '../controllers/projectController';

const router = express.Router();

router.get('/', getProjects);
router.post('/create-project', createProject);
router.post('/install-package', installPackage);
router.delete('/:projectName', deleteProject);

export default router;


---------
/// my-low-code-app/backend/src/server.ts

// backend/src/server.ts

import express from 'express';
import cors from 'cors';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import projectRoutes from './routes/projectRoutes';
import graphRoutes from './routes/graphRoutes';
import fileRoutes from './routes/fileRoutes';
import executeRoutes from './routes/executeRoutes';
import devServerRoutes from './routes/devServerRoutes';
import gitRoutes from './routes/gitRoutes'; // Si vous avez des routes Git
import authRoutes from './routes/authRoutes'; // Si vous avez des routes Git

import { errorHandler } from './middleware/errorHandler'; // Middleware de gestion des erreurs
import logger from './utils/logger'; // Importer le logger

// Documentation de l'API (par exemple Swagger)
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/projects', projectRoutes);
app.use('/project-graph', graphRoutes);
app.use('/update-file', fileRoutes);
app.use('/execute', executeRoutes);
app.use('/dev-server', devServerRoutes);
app.use('/git', gitRoutes); // Si vous avez des routes Git
app.use('/auth', authRoutes); // Si vous avez des routes d'authentification

// Configuration Swagger
const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Low-Code App API',
      version: '1.0.0',
    },
  },
  apis: ['./src/routes/*.ts'], // Chemin vers vos fichiers de routes
};

const specs = swaggerJsdoc(options);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

// Middleware de gestion des erreurs (doit être placé après toutes les routes)
app.use(errorHandler);

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/low-code-app')
  .then(() => {
    logger.info('Connected to MongoDB');
    // Démarrer le serveur seulement après la connexion à MongoDB
    app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => {
    logger.error(`MongoDB connection error: ${err.message}`);
  });


---------
/// my-low-code-app/backend/src/services/redis.ts

// src/services/redis.ts

import { createClient } from '@redis/client';
import logger from '../utils/logger';

class RedisService {
  private static instance: RedisService;
  private client: ReturnType<typeof createClient>;
  private isConnected: boolean = false;
  private reconnectAttempts: number = 0;
  private readonly MAX_RECONNECT_ATTEMPTS = 5;
  private readonly RECONNECT_INTERVAL = 1000; // 1 seconde

  private constructor() {
    this.initializeClient();
  }

  private initializeClient() {
    this.client = createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379',
      socket: {
        reconnectStrategy: (retries) => {
          if (retries > this.MAX_RECONNECT_ATTEMPTS) {
            logger.error('Max reconnection attempts reached, giving up');
            return new Error('Max reconnection attempts reached');
          }
          return this.RECONNECT_INTERVAL;
        }
      }
    });

    this.setupEventListeners();
  }

  private setupEventListeners() {
    this.client.on('error', (err) => {
      logger.error('Redis Client Error', err);
      this.isConnected = false;
    });

    this.client.on('connect', () => {
      logger.info('Redis Client Connected');
      this.isConnected = true;
      this.reconnectAttempts = 0;
    });

    this.client.on('reconnecting', () => {
      this.reconnectAttempts++;
      logger.info(`Redis Client Reconnecting... Attempt ${this.reconnectAttempts}`);
    });
  }

  public static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  public async connect(): Promise<void> {
    if (!this.isConnected) {
      try {
        await this.client.connect();
      } catch (error) {
        logger.error('Failed to connect to Redis:', error);
        throw error;
      }
    }
  }

  public async disconnect(): Promise<void> {
    if (this.isConnected) {
      await this.client.quit();
      this.isConnected = false;
    }
  }

  public isReady(): boolean {
    return this.isConnected;
  }

  public getClient() {
    if (!this.isConnected) {
      throw new Error('Redis client is not connected');
    }
    return this.client;
  }

  // Méthodes utilitaires avec gestion d'erreur
  public async get(key: string): Promise<string | null> {
    try {
      if (!this.isConnected) await this.connect();
      return await this.client.get(key);
    } catch (error) {
      logger.error(`Error getting key ${key}:`, error);
      return null;
    }
  }

  public async set(key: string, value: string, options?: { EX?: number; NX?: boolean }): Promise<boolean> {
    try {
      if (!this.isConnected) await this.connect();
      await this.client.set(key, value, options);
      return true;
    } catch (error) {
      logger.error(`Error setting key ${key}:`, error);
      return false;
    }
  }

  public async del(key: string): Promise<boolean> {
    try {
      if (!this.isConnected) await this.connect();
      await this.client.del(key);
      return true;
    } catch (error) {
      logger.error(`Error deleting key ${key}:`, error);
      return false;
    }
  }
}

export const redisService = RedisService.getInstance();
export default redisService;

---------
/// my-low-code-app/backend/src/types/queue.ts

export interface QueuedOperation {
    id: string;
    type: 'updateGraph' | 'deleteNode' | 'cloneNode';
    data: any;
    timestamp: number;
    requestHash: string;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    result?: any;
    error?: string;
  }


---------
/// my-low-code-app/backend/src/types.ts

// backend/src/types.ts

export interface NodePosition {
  x: number;
  y: number;
}

export interface NodeData {
  label: string;
  fileName: string;
  imports: string[];
  code: string;
  exportedFunctions: string[];
}

export interface Node {
  id: string;
  type: string;
  position: NodePosition;
  data: NodeData;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  label?: string;
}

export interface ProjectGraph {
  nodes: Node[];
  edges: Edge[];
}

---------
/// my-low-code-app/backend/src/utils/compileNodes.ts

import { INode } from '../models/Node';

export function compileNodes(nodes: INode[], entryFile: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Ajouter les imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Ajouter le code du node dans une closure
    compiledCode += `
(function(module, exports) {
  ${node.data.code}
})((module = { exports: {} }, exports = module.exports));
`;
    // Exporter les fonctions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `module.exports.${func} = ${func};\n`;
    });
  }

  // Commencer la compilation à partir du fichier d'entrée
  compileNode(entryFile);

  return compiledCode;
}


---------
/// my-low-code-app/backend/src/utils/executeCode.ts

import { exec } from 'child_process';
import path from 'path';

export const executeCode = (filePath: string, callback: (error: Error | null, result: { stdout: string; stderr: string } | null) => void) => {
  exec(`node ${filePath}`, (error, stdout, stderr) => {
    if (error) {
      console.error(`Execution error: ${error.message}`);
      return callback(error, null);
    }

    if (stderr) {
      console.error(`stderr: ${stderr}`);
      // Vous pouvez choisir d'envoyer stderr comme partie de la réponse
    }

    console.log(`stdout: ${stdout}`);
    callback(null, { stdout, stderr });
  });
};


---------
/// my-low-code-app/backend/src/utils/fileAnalyzer.ts

import fs from 'fs/promises';
import path from 'path';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import NodeModel, { INode } from '../models/Node';
import logger from '../utils/logger';

export interface FileAnalysisResult {
  nodes: INode[];
  imports: string[];
  exportedFunctions: string[];
}

export async function analyzeFile(
  filePath: string,
  projectId: string,
  projectPath: string
): Promise<FileAnalysisResult> {
  try {
    // Lire le contenu du fichier
    const content = await fs.readFile(filePath, 'utf-8');
    if (!content) {
      throw new Error(`Fichier vide: ${filePath}`);
    }

    // Analyser le code avec Babel
    const ast = parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    // Extraire les imports et exports
    const imports: string[] = [];
    const exportedFunctions: string[] = [];

    traverse(ast, {
      ImportDeclaration(path) {
        const source = path.node.source.value;
        imports.push(source);
      },
      ExportNamedDeclaration(path) {
        const { declaration } = path.node;
        if (declaration && declaration.type === 'FunctionDeclaration') {
          const funcName = declaration.id?.name;
          if (funcName) {
            exportedFunctions.push(funcName);
          }
        }
      },
    });

    // Créer le nœud
    const relativeFilePath = path.relative(projectPath, filePath);
    const nodeId = relativeFilePath.replace(/\\/g, '/');

    const nodeData = {
      project: projectId,
      id: nodeId,
      type: 'code',
      position: { 
        x: Math.random() * 500, 
        y: Math.random() * 500 
      },
      data: {
        label: path.basename(filePath),
        fileName: relativeFilePath,
        imports: imports,
        code: content,
        exportedFunctions: exportedFunctions,
        lintErrors: []
      }
    };

    // Sauvegarder le nœud
    const node = await NodeModel.findOneAndUpdate(
      { project: projectId, id: nodeId },
      nodeData,
      { upsert: true, new: true, runValidators: true }
    );

    if (!node) {
      throw new Error(`Échec de la création/mise à jour du nœud pour ${nodeId}`);
    }

    logger.info(`Nœud créé/mis à jour avec succès pour ${nodeId}`);

    return {
      nodes: [node],
      imports,
      exportedFunctions
    };

  } catch (error: any) {
    logger.error(`Erreur lors de l'analyse du fichier ${filePath}: ${error.message}`);
    throw error;
  }
}

---------
/// my-low-code-app/backend/src/utils/fileUtils.ts


import fs from 'fs/promises';
import path from 'path';
import logger from './logger';
import mkdirp from 'mkdirp'; // Ajoutez cette dépendance si ce n'est pas déjà fait

/**
 * Résout le chemin du fichier pour un projet donné.
 * @param project - Nom du projet.
 * @param fileName - Nom du fichier.
 * @returns Chemin complet du fichier.
 */
export async function getFilePath(project: string, fileName: string): Promise<string> {
  // Le dossier de base des projets
  const projectsBasePath = path.join(__dirname, '..', 'projects');
  const projectPath = path.join(projectsBasePath, project);
  
  // Construire le chemin complet du fichier
  const fullPath = path.join(projectPath, fileName);
  
  // S'assurer que le dossier parent existe
  const dirPath = path.dirname(fullPath);
  await mkdirp(dirPath);
  
  logger.info(`Built file path: ${fullPath}`);
  return fullPath;
}

/**
 * Écrit du contenu dans un fichier.
 * @param filePath - Chemin du fichier à écrire.
 * @param content - Contenu à écrire dans le fichier.
 */
export async function writeFile(filePath: string, content: string): Promise<void> {
  logger.info(`Attempting to write file: ${filePath}`);
  try {
    // S'assurer que le dossier parent existe
    const dirPath = path.dirname(filePath);
    await mkdirp(dirPath);
    
    // Écrire le fichier
    await fs.writeFile(filePath, content);
    logger.info(`File successfully written at ${filePath}`);
  } catch (error) {
    logger.error(`Error writing file at ${filePath}: ${(error as Error).message}`);
    throw error;
  }
}

---------
/// my-low-code-app/backend/src/utils/logger.ts

import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

export default logger;

---------
/// my-low-code-app/backend/src/utils.ts

import { Node, Edge } from './types';

/**
 * Function to sanitize variable names.
 * Replace all invalid characters with underscores.
 * @param name Variable name to sanitize.
 * @returns Sanitized variable name.
 */
function sanitizeVariableName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

export function compileNodes(nodes: Node[], entryNodeId: string): string {
  let compiledCode = '';
  const visitedNodes = new Set<string>();

  function compileNode(nodeId: string) {
    if (visitedNodes.has(nodeId)) return;
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.error(`Node with id ${nodeId} not found`);
      return;
    }

    // Add imports
    node.data.imports.forEach((imp: string) => {
      compiledCode += `${imp}\n`;
    });

    // Add node code within a closure
    const sanitizedFileName = sanitizeVariableName(node.data.fileName);
    compiledCode += `
const ${sanitizedFileName} = (function() {
  const module = { exports: {} };
  const exports = module.exports;
  ${node.data.code}
  return module.exports;
})();
`;

    // Export functions
    node.data.exportedFunctions.forEach((func: string) => {
      compiledCode += `if (typeof ${sanitizedFileName}.${func} === 'function') {
  globalThis.${func} = ${sanitizedFileName}.${func};
}\n`;
    });
  }

  // Start compilation from the entry node
  compileNode(entryNodeId);

  return compiledCode;
}


 my-low-code-app/frontend/src/App.tsx

// frontend/src/App.tsx

import React from 'react';
import { Box } from '@chakra-ui/react';
import { ReactFlowProvider } from 'reactflow';
import { Sidebar } from './components/Sidebar';
import { GraphCanvas } from './components/GraphCanvas';
import { Console } from './components/Console';
import { Modals } from './components/Modals';
import { ProjectStructure } from './components/ProjectStructure';
import { AlertProvider } from './contexts/AlertContext';
import { ProjectProvider } from './contexts/ProjectContext';
import { GraphProvider } from './contexts/GraphContext';
import ErrorBoundary from './components/ErrorBoundary';
import { ModalProvider } from './contexts/ModalContext';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <AlertProvider>
        <ProjectProvider>
          <GraphProvider>
            <ModalProvider>
              <ReactFlowProvider>
                <Box display="flex" height="100vh">
                  <Sidebar />
                  <GraphCanvas />
                  <Box display="flex" flexDirection="column" width="40%">
                    <ProjectStructure />
                    <Console />
                  </Box>
                  <Modals />
                </Box>
              </ReactFlowProvider>
            </ModalProvider>
          </GraphProvider>
        </ProjectProvider>
      </AlertProvider>
    </ErrorBoundary>
  );
};

export default App;
